 @RunWith(MockitoJUnitRunner.class)
public class TmlOnExchangeApsServiceImplTest {

    @InjectMocks
    private TmlOnExchangeApsServiceImpl service;

    @Before
    public void setUp() {
        // Set private fields if needed
        ReflectionTestUtils.setField(service, "cmeGroup", Collections.singleton("CME"));
        ReflectionTestUtils.setField(service, "iceUs", Collections.singleton("ICE"));
    }

    @Test
    public void testCheckForEachFill_cmeGroup_matchFound() throws Exception {
        // Prepare a fill
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setQuantityI(10);
        alloc.setPriceD(new BigDecimal("99.5"));
        alloc.setGmiExchCdC("CME");
        alloc.setTonIdC("XYZTN987654");

        List<TAllocationGenericId> fills = Arrays.asList(alloc);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACCT123");

        // Spy the service
        TmlOnExchangeApsServiceImpl spyService = Mockito.spy(service);

        // ======= MOCK getGmiParams (protected method) ========
        Map<String, Object> dummyParams = new HashMap<>();
        dummyParams.put("key", "value");
        doReturn(dummyParams).when(spyService).getGmiParams(any(), any(), any(), any());

        // ======= MOCK getClearHouseFeed (assume it's public/protected) ========
        TClearhouseMaster chMaster = new TClearhouseMaster();
        chMaster.setId(999L);
        chMaster.setLastQuantityI(10);
        chMaster.setTradePriceD(new BigDecimal("99.5"));
        chMaster.setExecIDC("TN987654");

        doReturn(Collections.singletonList(chMaster)).when(spyService).getClearHouseFeed(anyString(), anyMap());

        // ======= FORCE isBamlExecFirm (private method) to return true =======
        Method method = TmlOnExchangeApsServiceImpl.class.getDeclaredMethod("isBamlExecFirm", TAllocationGenericId.class);
        method.setAccessible(true);

        // Monkey patch it by replacing the method logic: override via ReflectionTestUtils
        TmlOnExchangeApsServiceImpl spyWithMockedPrivate = Mockito.spy(spyService);
        Mockito.doReturn(true).when(spyWithMockedPrivate, "isBamlExecFirm", any(TAllocationGenericId.class));

        // Call the method under test
        boolean result = ReflectionTestUtils.invokeMethod(spyWithMockedPrivate,
                "checkForEachFill", fills, chMsgs, accounts);

        // Verify output
        assertTrue(result);
        assertEquals(1, chMsgs.size());
        assertTrue(fills.get(0).isMatchFound());
    }
}



@RunWith(MockitoJUnitRunner.class)
public class TmlOnExchangeApsServiceImplTest {

    @InjectMocks
    private TmlOnExchangeApsServiceImpl service;

    @Mock
    private Logger log;

    @Before
    public void setup() throws Exception {
        // Override private method isBamlExecFirm to return true
        Method isBamlExecFirmMethod = TmlOnExchangeApsServiceImpl.class
            .getDeclaredMethod("isBamlExecFirm", TAllocationGenericId.class);
        isBamlExecFirmMethod.setAccessible(true);
        ReflectionTestUtils.setField(service, "cmeGroup", Collections.singleton("CME"));
        ReflectionTestUtils.setField(service, "iceUs", Collections.singleton("ICE"));
    }

    @Test
    public void testCheckForEachFill_AllMatch_BamlExec_CmeTon() throws Exception {
        // Setup input
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setQuantityI(100);
        alloc.setPriceD(new BigDecimal("10.5"));
        alloc.setGmiExchCdC("CME");
        alloc.setTonIdC("XYZTN123456");

        List<TAllocationGenericId> fills = Arrays.asList(alloc);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC123");

        // Mock getGmiParams
        Method getGmiParams = TmlOnExchangeApsServiceImpl.class.getDeclaredMethod(
                "getGmiParams", TAllocationGenericId.class, List.class, List.class, List.class);
        getGmiParams.setAccessible(true);

        Map<String, Object> gmiMap = new HashMap<>();
        gmiMap.put("dummy", "value");
        ReflectionTestUtils.setField(service, "log", Logger.getLogger("mocked"));

        Field getGmiParamsField = TmlOnExchangeApsServiceImpl.class.getDeclaredField("log");
        getGmiParamsField.setAccessible(true);
        getGmiParamsField.set(service, Logger.getLogger("mocked"));

        // Override private methods via ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(service, "filterIfBlockOrEfs", alloc); // optional if logic depends on it

        // Mock private method responses by subclassing or spying
        TmlOnExchangeApsServiceImpl spyService = Mockito.spy(service);
        doReturn(true).when(spyService).isBamlExecFirm(any());
        doReturn(gmiMap).when(spyService).getGmiParams(any(), any(), any(), any());

        // Stub getClearHouseFeed
        TClearhouseMaster chMaster = new TClearhouseMaster();
        chMaster.setId(1L);
        chMaster.setLastQuantityI(100);
        chMaster.setTradePriceD(new BigDecimal("10.5"));
        chMaster.setExecIDC("XYZTN123456");

        doReturn(Arrays.asList(chMaster)).when(spyService).getClearHouseFeed(anyString(), anyMap());

        boolean result = spyService.checkForEachFill(fills, chMsgs, accounts);

        assertTrue(result);
        assertEquals(1, chMsgs.size());
        assertTrue(fills.get(0).isMatchFound());
    }
}



@Test
public void testCheckForEachFill_allPathsCovered() throws Exception {
    // Setup
    TmlApsCHFeedUtil utilSpy = Mockito.spy(new TmlApsCHFeedUtil());
    ReflectionTestUtils.setField(utilSpy, "tmlQueryDao", mock(QueryDaoJdbc.class));
    ReflectionTestUtils.setField(utilSpy, "cmeGroup", new HashSet<>(Arrays.asList("CME")));
    ReflectionTestUtils.setField(utilSpy, "iceUs", new HashSet<>(Arrays.asList("ICE")));

    TAllocationGenericId alloc = new TAllocationGenericId();
    alloc.setQuantityI(100);
    alloc.setPriceD(new BigDecimal("10.5"));
    alloc.setGmiExchCdC("CME");
    alloc.setTonIdC("ABC123TN4567890");
    alloc.setExchangeTradeIdC("TRD123");
    alloc.setDownstreamStatusSw("NOT_MATCHED");

    List<TAllocationGenericId> fills = Arrays.asList(alloc);
    List<TClearhouseMaster> chMsgs = new ArrayList<>();
    List<String> accounts = Arrays.asList("ACC1");

    // Mock getGmiParams to return expected map
    Map<String, Object> gmiParams = new HashMap<>();
    gmiParams.put("dummy", "val");
    doReturn(gmiParams).when(utilSpy).getGmiParams(any(), any(), any(), any());

    // Mock getClearHouseFeed (private) using reflection to return a matching item
    TClearhouseMaster ch = new TClearhouseMaster();
    ch.setId(999L);
    ch.setExecIdC("TN4567890");
    ch.setLastQuantityI(BigDecimal.valueOf(100));
    ch.setTradePriceD(new BigDecimal("10.5"));
    ch.setAveragePriceD(new BigDecimal("10.5"));
    ch.setTradeIdC("TRD123");

    Method setPrivateList = TmlApsCHFeedUtil.class.getDeclaredMethod("getClearHouseFeed", String.class, Map.class);
    setPrivateList.setAccessible(true);
    doReturn(Arrays.asList(ch)).when(utilSpy, "getClearHouseFeed", anyString(), anyMap());

    // Use reflection to invoke the method under test
    Method method = TmlApsCHFeedUtil.class.getDeclaredMethod("checkForEachFill",
            List.class, List.class, List.class);
    method.setAccessible(true);
    boolean result = (boolean) method.invoke(utilSpy, fills, chMsgs, accounts);

    // Assert
    assertTrue(result);
    assertEquals(1, chMsgs.size());
    assertTrue(fills.get(0).isMatchFound());
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import java.util.*;
import org.apache.commons.collections4.CollectionUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class FillCheckerTest {

    @Mock
    private Logger log;
    
    @InjectMocks
    private YourServiceClass service; // Replace with actual class name
    
    private List<TAllocationGenericId> fills;
    private List<TClearhouseMaster> chMsgs;
    private List<String> accounts;
    private TAllocationGenericId alloc;
    private TClearhouseMaster chMaster;
    
    @Before
    public void setUp() {
        fills = new ArrayList<>();
        chMsgs = new ArrayList<>();
        accounts = Arrays.asList("ACC1", "ACC2");
        
        alloc = new TAllocationGenericId();
        alloc.setQuantityI(100);
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setGmiExchCdC("CME");
        alloc.setTonIdC("PRE123TN456");
        alloc.setExchangeTradeIdC("TRADE123");
        fills.add(alloc);
        
        chMaster = new TClearhouseMaster();
        chMaster.setId(1L);
        chMaster.setLastQuantityI(100);
        chMaster.setTradePriceD(new BigDecimal("100.50"));
        chMaster.setExecIdC("TN456");
        chMaster.setTradeIdC("TRADE123");
    }

    @Test
    public void testCheckForEachFill_CoverAllBranches() {
        // Test 1: Null/empty fills
        assertFalse(service.checkForEachFill(null, chMsgs, accounts));
        assertFalse(service.checkForEachFill(new ArrayList<>(), chMsgs, accounts));
        
        // Test 2: Successful match with CME TON ID (BAML executed firm)
        when(service.isBamlExecFirm(any())).thenReturn(true);
        when(service.getClearHouseFeed(anyString(), anyMap()))
            .thenReturn(Arrays.asList(chMaster));
        
        assertTrue(service.checkForEachFill(fills, chMsgs, accounts));
        assertEquals(1, chMsgs.size());
        verify(log).info("Matchig with CME TON ID data with trade price and BAML executed firm");
        
        // Test 3: Successful match with CME Trade ID (non-BAML executed firm)
        alloc.setTonIdC(null);
        when(service.isBamlExecFirm(any())).thenReturn(false);
        chMsgs.clear();
        
        assertTrue(service.checkForEachFill(fills, chMsgs, accounts));
        verify(log).info("Matchig with CME TRADE ID data with avg price");
        
        // Test 4: ICE exchange match
        alloc.setGmiExchCdC("ICE");
        alloc.setTonIdC("ICETON123");
        alloc.setExchangeTradeIdC(null);
        chMaster.setExecIdC("ICETON123");
        chMsgs.clear();
        
        assertTrue(service.checkForEachFill(fills, chMsgs, accounts));
        verify(log).info("Matchig with ICE TON data with avg price");
        
        // Test 5: No TON/Trade ID match (fallback to price/quantity)
        alloc.setTonIdC(null);
        alloc.setExchangeTradeIdC(null);
        chMsgs.clear();
        
        assertTrue(service.checkForEachFill(fills, chMsgs, accounts));
        verify(log).info("NO TON and TRADE ID for this, matching with price and quantity only");
        
        // Test 6: No matching clear house feed
        when(service.getClearHouseFeed(anyString(), anyMap()))
            .thenReturn(new ArrayList<>());
        
        assertFalse(service.checkForEachFill(fills, chMsgs, accounts));
        
        // Test 7: Partial match (not all fills matched)
        TAllocationGenericId alloc2 = new TAllocationGenericId();
        alloc2.setQuantityI(200);
        alloc2.setPriceD(new BigDecimal("200.50"));
        fills.add(alloc2);
        
        assertFalse(service.checkForEachFill(fills, chMsgs, accounts));
    }

    @Test
    public void testCheckForEachFill_EdgeCases() {
        // Test 1: Empty accounts list
        assertFalse(service.checkForEachFill(fills, chMsgs, new ArrayList<>()));
        
        // Test 2: Different quantity/price
        chMaster.setLastQuantityI(99);
        when(service.getClearHouseFeed(anyString(), anyMap()))
            .thenReturn(Arrays.asList(chMaster));
        
        assertFalse(service.checkForEachFill(fills, chMsgs, accounts));
        
        // Test 3: Already matched ID
        List<Long> idIL = new ArrayList<>();
        idIL.add(1L);
        when(service.getGmiParams(any(), any(), any(), any()))
            .thenReturn(Collections.singletonMap("ID_I", idIL));
        
        assertFalse(service.checkForEachFill(fills, chMsgs, accounts));
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.Logger;

@RunWith(MockitoJUnitRunner.class)
public class ClearHouseServiceTest {

    @Mock
    private TmlQueryDao tmlQueryDao;
    
    @Mock
    private Logger log;
    
    @InjectMocks
    private YourServiceClass yourServiceClass; // Replace with actual class name
    
    private Map<String, Object> testMap;
    private List<TClearhouseMaster> mockResultSet;
    private final String TEST_QUERY = "SELECT * FROM t_clearhouse_master";

    @Before
    public void setUp() {
        testMap = new HashMap<>();
        mockResultSet = new ArrayList<>();
        
        // Setup test data
        TClearhouseMaster tcm1 = new TClearhouseMaster();
        tcm1.setId(1001L);
        
        TClearhouseMaster tcm2 = new TClearhouseMaster();
        tcm2.setId(1002L);
        
        TClearhouseMaster tcm3 = new TClearhouseMaster();
        tcm3.setId(1003L);
        
        mockResultSet.add(tcm1);
        mockResultSet.add(tcm2);
        mockResultSet.add(tcm3);
    }

    @Test
    public void testGetClearHouseFeed_WithFiltering() {
        // Setup
        List<Long> idsToFilter = Arrays.asList(1001L, 1003L);
        testMap.put("ID_I", idsToFilter);
        
        when(tmlQueryDao.queryForRowMapperInCaluse(eq(TEST_QUERY), eq(testMap), any(TClearHouseMasterMapper.class)))
            .thenReturn(new ArrayList<>(mockResultSet));
        
        // Execute
        List<TClearhouseMaster> result = yourServiceClass.getClearHouseFeed(TEST_QUERY, testMap);
        
        // Verify
        assertEquals(1, result.size());
        assertEquals(Long.valueOf(1002L), result.get(0).getId());
        
        // Verify logging
        verify(log).info("getClearHouseFeed query is: " + TEST_QUERY);
        verify(log).info("getClearHouseFeed map is: " + testMap);
        verify(log, atLeastOnce()).info(contains("ID_I from t_clearhouse_master that its currently considering"));
        verify(log).info("~ID_I being removed = 1001, Length of resultSetList before removal = 3");
        verify(log).info("-Length of resultSetList after removal = 2");
        verify(log).info("~ID_I from t_clearhouse_master that its removing from result set = 1001");
        verify(log).info("~ID_I being removed = 1003, Length of resultSetList before removal = 2");
        verify(log).info("-Length of resultSetList after removal = 1");
        verify(log).info("~ID_I from t_clearhouse_master that its removing from result set = 1003");
    }

    @Test
    public void testGetClearHouseFeed_NoFiltering() {
        // Setup - no IDs to filter
        when(tmlQueryDao.queryForRowMapperInCaluse(eq(TEST_QUERY), eq(testMap), any(TClearHouseMasterMapper.class)))
            .thenReturn(new ArrayList<>(mockResultSet));
        
        // Execute
        List<TClearhouseMaster> result = yourServiceClass.getClearHouseFeed(TEST_QUERY, testMap);
        
        // Verify
        assertEquals(3, result.size());
        verify(log, never()).info(contains("ID_I being removed"));
    }

    @Test
    public void testGetClearHouseFeed_NullResultSet() {
        // Setup
        List<Long> idsToFilter = Arrays.asList(1001L);
        testMap.put("ID_I", idsToFilter);
        
        when(tmlQueryDao.queryForRowMapperInCaluse(anyString(), anyMap(), any()))
            .thenReturn(null);
        
        // Execute
        List<TClearhouseMaster> result = yourServiceClass.getClearHouseFeed(TEST_QUERY, testMap);
        
        // Verify
        assertNull(result);
        verify(log, never()).info(contains("ID_I being removed"));
    }

    @Test
    public void testGetClearHouseFeed_NullIdList() {
        // Setup - null ID list
        testMap.put("ID_I", null);
        
        when(tmlQueryDao.queryForRowMapperInCaluse(eq(TEST_QUERY), eq(testMap), any(TClearHouseMasterMapper.class)))
            .thenReturn(new ArrayList<>(mockResultSet));
        
        // Execute
        List<TClearhouseMaster> result = yourServiceClass.getClearHouseFeed(TEST_QUERY, testMap);
        
        // Verify
        assertEquals(3, result.size());
        verify(log, never()).info(contains("ID_I being removed"));
    }

    @Test
    public void testGetClearHouseFeed_EmptyIdList() {
        // Setup - empty ID list
        testMap.put("ID_I", new ArrayList<>());
        
        when(tmlQueryDao.queryForRowMapperInCaluse(eq(TEST_QUERY), eq(testMap), any(TClearHouseMasterMapper.class)))
            .thenReturn(new ArrayList<>(mockResultSet));
        
        // Execute
        List<TClearhouseMaster> result = yourServiceClass.getClearHouseFeed(TEST_QUERY, testMap);
        
        // Verify
        assertEquals(3, result.size());
        verify(log, never()).info(contains("ID_I being removed"));
    }
}



@Test
public void testProcessSumByBroker_WithValidAllocations() {
    // Mock dependencies
    TAllocationGenericMapper mapper = mock(TAllocationGenericMapper.class);
    AllocContainer allocContainer = mock(AllocContainer.class);
    
    // Setup test data
    List<TAllocationGenericId> allocations = new ArrayList<>();
    TAllocationGenericId alloc1 = new TAllocationGenericId();
    alloc1.setApsGroupKeyByBroker("BROKER1");
    allocations.add(alloc1);
    
    List<TAllocationGenericId> fills = new ArrayList<>();
    fills.add(alloc1);
    
    List<TClearhouseMaster> chMsgs = new ArrayList<>();
    chMsgs.add(new TClearhouseMaster());
    
    // Mock behavior
    when(getAllocations(anyString(), isNull(), any(TAllocationGenericMapper.class)))
        .thenReturn(allocations);
    when(allocContainer.getFills()).thenReturn(fills);
    when(checkIfFillsSumMatches(eq(fills), anyList(), anyString())).thenReturn(true);
    
    // Execute
    processSumByBroker();
    
    // Verify
    verify(log, times(2)).info(anyString());
    verify(log, never()).warn(anyString());
    verify(allocContainer, atLeastOnce()).getFills();
    verify(updateStatus(any(MessageStatus.class), anyList(), any(AllocContainer.class), anyString()));
}


@Test
public void testPopulateStatusMsgWithGroup_BufferLengthTruncation() {
    // Setup - Create message that will exceed 4000 chars when combined with IDs
    String msg = "Status: ";
    
    // Create enough TClearhouseMaster objects to exceed the limit
    List<TClearhouseMaster> longList = new ArrayList<>();
    for (long i = 1; i <= 500; i++) {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setId(i);
        longList.add(master);
    }
    
    // Execute
    String result = populateStatusMsgWithGroup(msg, longList);
    
    // Verify the truncation
    assertEquals(3999, result.length()); // Should be exactly 3999 chars
    assertTrue(result.startsWith(msg)); // Should start with original message
    assertTrue(result.endsWith(",")); // Should end with comma from last ID
    
    // Verify the truncation point doesn't cut a number in half
    String lastNumber = result.substring(result.lastIndexOf(",") - 4, result.lastIndexOf(","));
    assertTrue(lastNumber.matches("\\d+")); // Should be a complete number
    
    // Verify the content before truncation is preserved
    assertTrue(result.contains("1,2,3,")); // Early items should be present
    
    // Edge case: Verify behavior when exactly at boundary
    String exactSizeMsg = "X".repeat(3990);
    List<TClearhouseMaster> smallList = new ArrayList<>();
    TClearhouseMaster m = new TClearhouseMaster();
    m.setId(123L);
    smallList.add(m);
    
    String exactResult = populateStatusMsgWithGroup(exactSizeMsg, smallList);
    assertEquals(3999, exactResult.length()); // "X...X123," = exactly 3999
}


import static org.junit.Assert.*;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.collections4.CollectionUtils;
import org.junit.Before;
import org.junit.Test;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;

public class StatusMessageUtilTest {

    private List<TClearhouseMaster> chMsgs;
    private final String TEST_MSG = "Test message: ";

    @Before
    public void setUp() {
        chMsgs = new ArrayList<>();
    }

    @Test
    public void testPopulateStatusMsgWithGroup_EmptyList() {
        // Setup
        String msg = TEST_MSG;
        
        // Execute
        String result = populateStatusMsgWithGroup(msg, chMsgs);
        
        // Verify
        assertEquals(msg, result);
    }

    @Test
    public void testPopulateStatusMsgWithGroup_SingleItem() {
        // Setup
        String msg = TEST_MSG;
        TClearhouseMaster master = new TClearhouseMaster();
        master.setId(1001L);
        chMsgs.add(master);
        
        // Execute
        String result = populateStatusMsgWithGroup(msg, chMsgs);
        
        // Verify
        assertEquals(msg + "1001,", result);
    }

    @Test
    public void testPopulateStatusMsgWithGroup_MultipleItems() {
        // Setup
        String msg = TEST_MSG;
        for (long i = 1; i <= 5; i++) {
            TClearhouseMaster master = new TClearhouseMaster();
            master.setId(i);
            chMsgs.add(master);
        }
        
        // Execute
        String result = populateStatusMsgWithGroup(msg, chMsgs);
        
        // Verify
        assertEquals(msg + "1,2,3,4,5,", result);
    }

    @Test
    public void testPopulateStatusMsgWithGroup_NullList() {
        // Setup
        String msg = TEST_MSG;
        
        // Execute
        String result = populateStatusMsgWithGroup(msg, null);
        
        // Verify
        assertEquals(msg, result);
    }

    @Test
    public void testPopulateStatusMsgWithGroup_MessageTruncation() {
        // Setup
        String msg = TEST_MSG;
        
        // Create a long list that will exceed 4000 characters when combined with msg
        for (int i = 0; i < 500; i++) {
            TClearhouseMaster master = new TClearhouseMaster();
            master.setId(1000000L + i);
            chMsgs.add(master);
        }
        
        // Execute
        String result = populateStatusMsgWithGroup(msg, chMsgs);
        
        // Verify
        assertTrue(result.length() <= 3999);
        assertEquals(3999, result.length());
        assertTrue(result.startsWith(msg));
    }

    @Test
    public void testPopulateStatusMsgWithGroup_EmptyMessage() {
        // Setup
        String msg = "";
        TClearhouseMaster master = new TClearhouseMaster();
        master.setId(1001L);
        chMsgs.add(master);
        
        // Execute
        String result = populateStatusMsgWithGroup(msg, chMsgs);
        
        // Verify
        assertEquals("1001,", result);
    }

    // Helper method to test (since original method might be private)
    private String populateStatusMsgWithGroup(String msg, List<TClearhouseMaster> chMsgs) {
        StringBuffer buffer = new StringBuffer();
        buffer.append(msg);
        
        if (CollectionUtils.isNotEmpty(chMsgs)) {
            for (TClearhouseMaster clearhouseMaster : chMsgs) {
                buffer.append(clearhouseMaster.getId()).append(",");
            }
            
            if (buffer.length() > 3999) {
                return buffer.substring(0, 3998);
            }
        }
        
        return buffer.toString();
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import com.baml.tml.tmlbase.trade.model.AllocClientStaticContainer;
import com.baml.tml.tmlbase.trade.persistence.dao.TAllocationGenericId;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;
import com.baml.tml.tmlbase.trade.util.RecursiveExitException;
import com.baml.tml.tmlbase.trade.util.RecursiveTooManyCallsExitException;
import com.baml.tml.tmlbase.trade.util.SubsetCHMaster;

@RunWith(MockitoJUnitRunner.class)
public class TmlOnExchangeApsServiceImplTest {

    @Mock
    private Logger log;
    
    @Mock
    private AllocClientStaticContainer allocClientStaticContainer;
    
    @Mock
    private TAllocationGenericId alloc1, alloc2;
    
    @Mock
    private TClearhouseMaster chMaster1, chMaster2;
    
    @InjectMocks
    private TmlOnExchangeApsServiceImpl service;
    
    private List<String> testSuspenseAccounts;
    
    @Before
    public void setUp() throws Exception {
        testSuspenseAccounts = Arrays.asList("SUSP1", "SUSP2");
        
        when(allocClientStaticContainer.clientSuspenseAccounts()).thenReturn(testSuspenseAccounts);
        when(log.isInfoEnabled()).thenReturn(true);
        when(log.isErrorEnabled()).thenReturn(true);
        
        // Initialize clientStaticMap through reflection
        Map<String, AllocClientStaticContainer> clientStaticMap = new HashMap<>();
        setPrivateField(service, "clientStaticMap", clientStaticMap);
    }
    
    // Helper method to set private fields using reflection
    private void setPrivateField(Object target, String fieldName, Object value) 
            throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
    
    // Helper method to get private field using reflection
    @SuppressWarnings("unchecked")
    private Map<String, AllocClientStaticContainer> getClientStaticMap() 
            throws Exception {
        Field field = service.getClass().getDeclaredField("clientStaticMap");
        field.setAccessible(true);
        return (Map<String, AllocClientStaticContainer>) field.get(service);
    }
    
    @Test
    public void testClientSusaAccount_WithExistingClient() throws Exception {
        // Setup
        getClientStaticMap().put("TEST_CLIENT", allocClientStaticContainer);
        
        // Execute
        List<String> result = service.clientSusaAccount("TEST_CLIENT");
        
        // Verify
        assertEquals(testSuspenseAccounts, result);
    }
    
    @Test
    public void testClientSusaAccount_WithNonExistingClient() throws Exception {
        // Execute
        List<String> result = service.clientSusaAccount("NON_EXISTING_CLIENT");
        
        // Verify
        assertNull(result);
    }
    
    @Test
    public void testSleep_InterruptedException() {
        // Setup
        Thread.currentThread().interrupt();
        
        // Execute
        service.sleep(0);
        
        // Verify
        verify(log).error(contains("error occured while sleeping"), any(InterruptedException.class));
        assertTrue(Thread.interrupted()); // Clears interrupt status
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithMatchingFills() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1, alloc2);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1", "ACC2");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc2.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        when(alloc2.getQuantityI()).thenReturn(200);
        
        // Mock the database query result
        List<TClearhouseMaster> mockFeed = Arrays.asList(chMaster1, chMaster2);
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(mockFeed);
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertTrue(result);
        assertEquals(2, chMsgs.size());
        verify(log).info(contains("sum of qty for price:10.0"));
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithRecursiveExitException() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        
        List<TClearhouseMaster> mockFeed = Arrays.asList(chMaster1, chMaster2);
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(mockFeed);
        
        // Mock SubsetCHMaster to throw RecursiveExitException
        doThrow(new RecursiveExitException()).when(service)
            .mockSubsetCHMasterSumUp(anyList(), anyInt(), anyList());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertTrue(result);
        verify(log).info("found a match with recursive");
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithEmptyResult() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        
        // Return empty list from database query
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(new ArrayList<>());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertFalse(result);
        assertTrue(chMsgs.isEmpty());
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithValidContainer() throws Exception {
        // Setup mock container
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(false);
        when(container.hasSamePriceQty(5)).thenReturn(true);
        
        // Setup mock database result
        Map<String, AllocContainer> mockMap = new HashMap<>();
        mockMap.put("TEST_KEY", container);
        when(service.getAllocs(anyString())).thenReturn(mockMap);
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start processByReplayPartialGroups()");
        verify(log).info("Start updating match status N to RTS.");
        verify(log).info("Completed processByReplayPartialGroups()");
        verify(service).updateMatchedStatus(any(MessageStatus.class), eq(container));
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import com.baml.tml.tmlbase.trade.model.AllocClientStaticContainer;
import com.baml.tml.tmlbase.trade.persistence.dao.TAllocationGenericId;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;
import com.baml.tml.tmlbase.trade.util.RecursiveExitException;
import com.baml.tml.tmlbase.trade.util.RecursiveTooManyCallsExitException;
import com.baml.tml.tmlbase.trade.util.SubsetCHMaster;

@RunWith(MockitoJUnitRunner.class)
public class TmlOnExchangeApsServiceImplAdditionalTest {

    @Mock
    private Logger log;
    
    @Mock
    private AllocClientStaticContainer allocClientStaticContainer;
    
    @Mock
    private TAllocationGenericId alloc1, alloc2;
    
    @Mock
    private TClearhouseMaster chMaster1, chMaster2;
    
    @InjectMocks
    private TmlOnExchangeApsServiceImpl service;
    
    private Map<String, AllocClientStaticContainer> clientStaticMap;
    private List<String> testSuspenseAccounts;
    
    @Before
    public void setUp() {
        clientStaticMap = new HashMap<>();
        testSuspenseAccounts = Arrays.asList("SUSP1", "SUSP2");
        
        when(allocClientStaticContainer.clientSuspenseAccounts()).thenReturn(testSuspenseAccounts);
        when(log.isInfoEnabled()).thenReturn(true);
        when(log.isErrorEnabled()).thenReturn(true);
    }
    
    // Test for clientSusaAccount method
    @Test
    public void testClientSusaAccount_WithExistingClient() {
        // Setup
        clientStaticMap.put("TEST_CLIENT", allocClientStaticContainer);
        service.setClientStaticMap(clientStaticMap);
        
        // Execute
        List<String> result = service.clientSusaAccount("TEST_CLIENT");
        
        // Verify
        assertEquals(testSuspenseAccounts, result);
    }
    
    @Test
    public void testClientSusaAccount_WithNonExistingClient() {
        // Setup
        service.setClientStaticMap(clientStaticMap);
        
        // Execute
        List<String> result = service.clientSusaAccount("NON_EXISTING_CLIENT");
        
        // Verify
        assertNull(result);
    }
    
    @Test
    public void testClientSusaAccount_WithNullClient() {
        // Setup
        service.setClientStaticMap(clientStaticMap);
        
        // Execute
        List<String> result = service.clientSusaAccount(null);
        
        // Verify
        assertNull(result);
    }
    
    // Test for sleep method
    @Test
    public void testSleep_Successful() {
        // Execute
        service.sleep(0); // 0 seconds for test
        
        // Verify no exception thrown
    }
    
    @Test
    public void testSleep_InterruptedException() {
        // Setup
        Thread.currentThread().interrupt();
        
        // Execute
        service.sleep(0);
        
        // Verify
        verify(log).error(contains("error occured while sleeping"), any(InterruptedException.class));
        assertTrue(Thread.interrupted()); // Clears interrupt status
    }
    
    // Test for checkIfFillsSumMatches method
    @Test
    public void testCheckIfFillsSumMatches_WithMatchingFills() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1, alloc2);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1", "ACC2");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc2.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        when(alloc2.getQuantityI()).thenReturn(200);
        
        List<TClearhouseMaster> mockFeed = Arrays.asList(chMaster1, chMaster2);
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(mockFeed);
        
        // Mock SubsetCHMaster to not throw exception (simulate success)
        doNothing().when(service).mockSubsetCHMasterSumUp(anyList(), anyInt(), anyList());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertTrue(result);
        assertEquals(2, chMsgs.size());
        verify(log).info(contains("sum of qty for price:10.0"));
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithRecursiveExitException() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        
        List<TClearhouseMaster> mockFeed = Arrays.asList(chMaster1, chMaster2);
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(mockFeed);
        
        // Mock SubsetCHMaster to throw RecursiveExitException
        doThrow(new RecursiveExitException()).when(service)
            .mockSubsetCHMasterSumUp(anyList(), anyInt(), anyList());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertTrue(result);
        verify(log).info("found a match with recursive");
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithRecursiveTooManyCallsException() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        
        List<TClearhouseMaster> mockFeed = Arrays.asList(chMaster1, chMaster2);
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(mockFeed);
        
        // Mock SubsetCHMaster to throw RecursiveTooManyCallsExitException
        doThrow(new RecursiveTooManyCallsExitException()).when(service)
            .mockSubsetCHMasterSumUp(anyList(), anyInt(), anyList());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertFalse(result);
        verify(log).info("too many calls doesn't found a match with recursive:");
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithEmptyFilteredList() throws Exception {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc1.getQuantityI()).thenReturn(100);
        
        List<TClearhouseMaster> mockFeed = Arrays.asList(chMaster1, chMaster2);
        when(service.getClearHouseFeedoriginal(anyString(), anyMap())).thenReturn(mockFeed);
        
        // Mock SubsetCHMaster to produce empty filtered list
        doAnswer(invocation -> {
            List<TClearhouseMaster> filtered = invocation.getArgumentAt(2, List.class);
            filtered.clear();
            return null;
        }).when(service).mockSubsetCHMasterSumUp(anyList(), anyInt(), anyList());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertFalse(result);
        verify(log).info("no of fills0");
    }
    
    @Test
    public void testCheckIfFillsSumMatches_WithMultiplePrices() {
        // Setup
        List<TAllocationGenericId> fills = Arrays.asList(alloc1, alloc2);
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        List<String> accounts = Arrays.asList("ACC1", "ACC2");
        
        when(alloc1.getPriceD()).thenReturn(10.0);
        when(alloc2.getPriceD()).thenReturn(20.0); // Different price
        when(alloc1.getQuantityI()).thenReturn(100);
        when(alloc2.getQuantityI()).thenReturn(200);
        
        List<TClearhouseMaster> mockFeed1 = Arrays.asList(chMaster1);
        List<TClearhouseMaster> mockFeed2 = Arrays.asList(chMaster2);
        
        when(service.getClearHouseFeedoriginal(anyString(), anyMap()))
            .thenReturn(mockFeed1)  // For price 10.0
            .thenReturn(mockFeed2); // For price 20.0
        
        doNothing().when(service).mockSubsetCHMasterSumUp(anyList(), anyInt(), anyList());
        
        // Execute
        boolean result = service.checkIfFillsSumMatches(fills, chMsgs, accounts);
        
        // Verify
        assertTrue(result);
        assertEquals(2, chMsgs.size());
        verify(log, times(2)).info(contains("sum of qty for price:"));
    }
}


import static org.mockito.Mockito.*;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import com.baml.tml.tmlaps.model.MessageStatus;
import com.baml.tml.tmlbase.trade.model.AllocContainer;
import com.baml.tml.tmlbase.trade.persistence.dao.TAllocationGenericId;
import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;

@RunWith(MockitoJUnitRunner.class)
public class ProcessByReplayPartialGroupsConditionsTest {

    @Mock
    private QueryDaoJdbc tmlQueryDao;
    
    @InjectMocks
    private TmlOnExchangeApsServiceImpl service;
    
    private Map<String, AllocContainer> testData;
    
    @Before
    public void setUp() {
        testData = new HashMap<>();
    }
    
    @Test
    public void testContainerWithOnlyAvg() {
        // Setup container with only avg (no fills)
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(true);
        
        testData.put("TEST_KEY", container);
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify
        verify(container).hasOnlyAvg();
        verify(service).statusFailure("TEST_KEY", container);
        verify(service, never()).updateMatchedStatus(any(), any());
    }
    
    @Test
    public void testContainerWithPriceQtyMismatch() {
        // Setup container with price/qty mismatch
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(false);
        when(container.hasSamePriceQty(5)).thenReturn(false);
        
        testData.put("TEST_KEY", container);
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify
        verify(container).hasOnlyAvg();
        verify(container).hasSamePriceQty(5);
        verify(service).statusFailure("TEST_KEY", container);
        verify(service, never()).updateMatchedStatus(any(), any());
    }
    
    @Test
    public void testContainerWithMatchingFills() {
        // Setup container with matching fills and avg
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(false);
        when(container.hasSamePriceQty(5)).thenReturn(true);
        
        testData.put("TEST_KEY", container);
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify
        verify(container).hasOnlyAvg();
        verify(container).hasSamePriceQty(5);
        verify(service).updateMatchedStatus(
            argThat(msg -> "RTS".equals(msg.getStatus())),
            eq(container)
        );
        verify(service, never()).statusFailure(any(), any());
    }
    
    @Test
    public void testEmptyContainerMap() {
        // Setup empty map
        testData.clear();
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify no failures or updates called
        verify(service, never()).statusFailure(any(), any());
        verify(service, never()).updateMatchedStatus(any(), any());
    }
    
    @Test
    public void testContainerWithNullValues() {
        // Setup container with null values
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(true); // Treat as only avg
        
        testData.put("TEST_KEY", container);
        testData.put("NULL_KEY", null);
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify
        verify(service).statusFailure("TEST_KEY", container);
        // Should handle null container without throwing exception
    }
    
    @Test
    public void testLoggingBehavior() {
        // Setup valid container
        AllocContainer container = mock(AllocContainer.class);
        when(container.hasOnlyAvg()).thenReturn(false);
        when(container.hasSamePriceQty(5)).thenReturn(true);
        
        testData.put("TEST_KEY", container);
        
        // Execute
        service.processByReplayPartialGroups();
        
        // Verify logging
        verify(service.getLogger()).info("Start processByReplayPartialGroups()");
        verify(service.getLogger()).info(contains("REPLAY FILL SQL query="));
        verify(service.getLogger()).info("Start updating match status N to RTS.");
        verify(service.getLogger()).info("Completed processByReplayPartialGroups()");
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.jdbc.support.rowset.SqlRowSet;

import com.baml.tml.tmlaps.model.MessageStatus;
import com.baml.tml.tmlaps.onExchange.service.TmlOnExchangeApsService;
import com.baml.tml.tmlbase.trade.model.AllocContainer;
import com.baml.tml.tmlbase.trade.persistence.dao.TAllocationGenericId;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;
import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;

@RunWith(MockitoJUnitRunner.class)
public class TmlOnExchangeApsServiceImplTest {

    @Mock
    private QueryDaoJdbc tmlQueryDao;
    
    @Mock
    private Logger log;
    
    @Mock
    private SqlRowSet rowSet;
    
    @InjectMocks
    private TmlOnExchangeApsServiceImpl service = new TmlOnExchangeApsServiceImpl();
    
    private Map<String, AllocContainer> testContainerMap;
    
    @Before
    public void setUp() throws Exception {
        // Initialize test data
        testContainerMap = new HashMap<>();
        
        // Set up mock behavior for logger
        Logger realLogger = Logger.getLogger(TmlOnExchangeApsServiceImpl.class);
        when(log.isInfoEnabled()).thenReturn(true);
        when(log.isWarnEnabled()).thenReturn(true);
        when(log.isErrorEnabled()).thenReturn(true);
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithValidContainer() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId fill1 = new TAllocationGenericId();
        fill1.setPrice(10.0);
        fill1.setQty(100);
        container.setFills(Arrays.asList(fill1));
        
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(10.0);
        avg1.setQty(100);
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start processByReplayPartialGroups()");
        verify(log).info(contains("REPLAY FILL SQL query="));
        verify(log).info("Start updating match status N to RTS.");
        verify(log).info("Completed processByReplayPartialGroups()");
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithOnlyAvg() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(10.0);
        avg1.setQty(100);
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).warn(contains(":no Fills:"));
        verify(log, never()).info("Start updating match status N to RTS.");
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithPriceQtyMismatch() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId fill1 = new TAllocationGenericId();
        fill1.setPrice(10.0);
        fill1.setQty(100);
        container.setFills(Arrays.asList(fill1));
        
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(20.0); // Different price
        avg1.setQty(100);
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).warn(contains("still doesn't match fills against avg trades sum(price*qty)"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithEmptyContainerMap() {
        // Setup
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start processByReplayPartialGroups()");
        verify(log).info("Completed processByReplayPartialGroups()");
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithDatabaseException() {
        // Setup
        when(tmlQueryDao.getRowSet(anyString())).thenThrow(new RuntimeException("DB Error"));
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).error(contains("error occurred while processing replay partial groups"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithNullContainer() {
        // Setup
        testContainerMap.put("TEST_KEY", null);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).error(contains("Null container found for key"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithEmptyFillsAndAvg() {
        // Setup
        AllocContainer container = new AllocContainer();
        container.setFills(new ArrayList<>());
        container.setAvg(new ArrayList<>());
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).warn(contains(":no Fills:"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithMultipleFillsAndAvg() {
        // Setup
        AllocContainer container = new AllocContainer();
        
        // Create fills
        TAllocationGenericId fill1 = new TAllocationGenericId();
        fill1.setPrice(10.0);
        fill1.setQty(100);
        
        TAllocationGenericId fill2 = new TAllocationGenericId();
        fill2.setPrice(10.0);
        fill2.setQty(50);
        
        container.setFills(Arrays.asList(fill1, fill2));
        
        // Create avg
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(10.0);
        avg1.setQty(150); // Sum of fills qty
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start updating match status N to RTS.");
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.PropertyException;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.jdbc.support.rowset.SqlRowSet;

@RunWith(MockitoJUnitRunner.class)
public class TmlApsExchangeConnectorServiceImplTest {

    @Mock
    private TClearhouseMasterDao tClearhouseMasterDao;
    
    @Mock
    private SqlRowSet rowSet;
    
    @Mock
    private SqlRowSet rowSetAvg;
    
    @InjectMocks
    private TmlApsExchangeConnectorServiceImpl service;
    
    private List<TClearhouseMaster> mockMasterList;
    private TClearhouseMaster mockMaster;
    
    @Before
    public void setUp() {
        mockMaster = new TClearhouseMaster();
        mockMaster.setId(123L);
        mockMaster.setExchangeCdC("EXCH1");
        mockMaster.setApsGroupIdC("GROUP1");
        
        mockMasterList = new ArrayList<>();
        mockMasterList.add(mockMaster);
    }

    @Test
    public void testProcessToCompleteApsGroup_HappyPath() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("VALID_CLIENT");
        
        // Mock average price response
        when(rowSetAvg.next()).thenReturn(true).thenReturn(false);
        when(rowSetAvg.getBigDecimal("AVERAGE_PRICE_D")).thenReturn(new BigDecimal("100.50"));
        when(tClearhouseMasterDao.getAvgPriceGroupCompletion(anyString(), anyLong())).thenReturn(rowSetAvg);
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify interactions
        verify(tClearhouseMasterDao).completeApsGroup("EXCH1", "GROUP1");
        verify(tClearhouseMasterDao).updateGenericAvgPriceList(any(BigDecimal.class), eq("GROUP1"));
    }

    @Test
    public void testProcessToCompleteApsGroup_EmptyClientName() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses with empty client name
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("");
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no message was sent
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }

    @Test
    public void testProcessToCompleteApsGroup_NullClientName() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses with null client name
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn(null);
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no message was sent
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }

    @Test
    public void testProcessToCompleteApsGroup_ClientInExclusionList() throws Exception {
        // Set up exclusion list
        service.avgNotReqString = "EXCLUDED_CLIENT,ANOTHER_CLIENT";
        
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses with excluded client
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("EXCLUDED_CLIENT");
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no message was sent
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }

    @Test
    public void testProcessToCompleteApsGroup_EmptyMasterList() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock empty master list
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(new ArrayList<>());
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no interactions with message sending
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }
}



import org.springframework.test.util.ReflectionTestUtils;

@Test
public void testGetQ_WithSpringUtils() {
    // Setup
    mockMaster.setExchangeCdC("IFUS");
    mockMaster.setDestIdC("DEST1");
    
    Map<String, String> queues = new HashMap<>();
    queues.put("IFUS.DEST1", "TEST.QUEUE");
    
    // Set private field
    ReflectionTestUtils.setField(service, "outBoundQueues", queues);
    
    // Invoke private method
    String result = ReflectionTestUtils.invokeMethod(service, "getQ", mockMaster);
    
    assertEquals("TEST.QUEUE", result);
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.jms.JMSException;
import javax.xml.bind.JAXBException;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.jdbc.support.rowset.SqlRowSet;

import com.baml.tml.tmlbase.trade.clearhouse.fixml.Fixml;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMasterDao;
import com.baml.tml.tmlbase.trade.util.FileMessage;
import com.baml.tml.tmlbase.trade.util.TmlMqMessageWriter;

@RunWith(MockitoJUnitRunner.class)
public class TmlApsExchangeConnectorServiceImplTest {

    @Mock
    private TClearhouseMasterDao tClearhouseMasterDao;
    
    @Mock
    private TmlMqMessageWriter tmlMqMessageWriter;
    
    @Mock
    private FileMessage fileMessage;
    
    @Mock
    private Map<String, String> outBoundQueues;
    
    @Mock
    private Logger log;
    
    @InjectMocks
    private TmlApsExchangeConnectorServiceImpl service;
    
    private TClearhouseMaster mockMaster;
    private List<TClearhouseMaster> mockList;
    
    @Before
    public void setUp() {
        mockMaster = new TClearhouseMaster();
        mockMaster.setId(123L);
        mockMaster.setExchangeCdC("EXCH1");
        mockMaster.setDestIdC("DEST1");
        mockMaster.setApsGroupIdC("GROUP1");
        
        mockList = new ArrayList<>();
        mockList.add(mockMaster);
    }

    @Test
    public void testProcessMatchedMsgs_EmptyList() throws JAXBException, JMSException {
        when(tClearhouseMasterDao.listClearHouseMaster()).thenReturn(new ArrayList<>());
        
        service.processMatchedMsgs();
        
        verify(tClearhouseMasterDao).listClearHouseMaster();
        verifyNoMoreInteractions(tClearhouseMasterDao, tmlMqMessageWriter, fileMessage);
    }

    @Test
    public void testProcessMatchedMsgs_WithRecords() throws JAXBException, JMSException {
        when(tClearhouseMasterDao.listClearHouseMaster()).thenReturn(mockList);
        when(outBoundQueues.get(anyString())).thenReturn("TEST.QUEUE");
        
        service.processMatchedMsgs();
        
        verify(tClearhouseMasterDao).listClearHouseMaster();
        verify(tClearhouseMasterDao).updateMatchedStatus(anyList(), eq("S"));
        verify(fileMessage).writeMessageToFile(anyString());
        verify(tmlMqMessageWriter).sendMessage(anyString(), anyString());
    }

    @Test
    public void testProcessToCompleteApsGroup() throws PropertyException, JAXBException, JMSException {
        SqlRowSet mockRowSet = mock(SqlRowSet.class);
        when(mockRowSet.next()).thenReturn(true).thenReturn(false);
        when(mockRowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(mockRowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(mockRowSet.getLong("LOTS")).thenReturn(100L);
        
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(mockRowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("CLIENT1");
        when(outBoundQueues.get(anyString())).thenReturn("TEST.QUEUE");
        
        SqlRowSet mockAvgRowSet = mock(SqlRowSet.class);
        when(mockAvgRowSet.next()).thenReturn(true).thenReturn(false);
        when(mockAvgRowSet.getBigDecimal("AVERAGE_PRICE_D")).thenReturn(new BigDecimal("100.50"));
        when(tClearhouseMasterDao.getAvgPriceGroupCompletion(anyString(), anyLong())).thenReturn(mockAvgRowSet);
        
        service.processToCompleteApsGroup();
        
        verify(tClearhouseMasterDao).qtyByGroup();
        verify(tClearhouseMasterDao).listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString());
        verify(tClearhouseMasterDao).getClientName(anyString());
        verify(tClearhouseMasterDao).getAvgPriceGroupCompletion(anyString(), anyLong());
        verify(tClearhouseMasterDao).updateGenericAvgPriceList(any(BigDecimal.class), anyString());
        verify(tClearhouseMasterDao).completeApsGroup(anyString(), anyString());
        verify(fileMessage).writeMessageToFile(anyString());
        verify(tmlMqMessageWriter).sendMessage(anyString(), anyString());
    }

    @Test
    public void testGetQ_WithDestId() {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setExchangeCdC("IFUS");
        master.setDestIdC("DEST1");
        
        Map<String, String> queues = new HashMap<>();
        queues.put("IFUS.DEST1", "TEST.QUEUE");
        service.outBoundQueues = queues;
        
        String result = service.getQ(master);
        assertEquals("TEST.QUEUE", result);
    }

    @Test
    public void testGetQ_WithoutDestId() {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setExchangeCdC("EXCH1");
        
        Map<String, String> queues = new HashMap<>();
        queues.put("EXCH1", "TEST.QUEUE");
        service.outBoundQueues = queues;
        
        String result = service.getQ(master);
        assertEquals("TEST.QUEUE", result);
    }

    @Test
    public void testGetQ_NoQueueConfigured() {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setExchangeCdC("UNKNOWN");
        
        Map<String, String> queues = new HashMap<>();
        service.outBoundQueues = queues;
        
        String result = service.getQ(master);
        assertNull(result);
    }

    @Test
    public void testUpdateStatus() {
        List<Long> ids = Arrays.asList(1L, 2L, 3L);
        service.updateStatus(ids, "S");
        verify(tClearhouseMasterDao).updateMatchedStatus(ids, "S");
    }

    @Test
    public void testWriteMsgToExchange() throws JMSException {
        when(outBoundQueues.get(anyString())).thenReturn("TEST.QUEUE");
        
        service.writeMsgToExchange(mockMaster, "<test>message</test>");
        
        verify(fileMessage).writeMessageToFile(anyString());
        verify(tmlMqMessageWriter).sendMessage(anyString(), anyString());
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.sql.SQLException;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.support.rowset.SqlRowSet;

@RunWith(MockitoJUnitRunner.class)
public class TmlApsCHFeedUtilTest {

    @InjectMocks
    private TmlApsCHFeedUtil tmlApsCHFeedUtil;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private Logger log;

    @Mock
    private ImlCollectionUtil util;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // Inject mock logger via reflection if needed
    }

    @Test
    public void testUpdateStatusWithClientProvidedGroupId() {
        // Setup
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        TClearhouseMaster chMsg = new TClearhouseMaster();
        chMsg.setIdI(123L);
        chMsgs.add(chMsg);

        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientProvidedApsGrpIdC("CLIENT12345");
        container.addAsFillAndAvg(alloc);

        // Mock behavior
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Execute
        boolean result = tmlApsCHFeedUtil.updateStatus(
            new MessageStatus("STATUS", "MSG"), 
            chMsgs, 
            container, 
            true
        );

        // Verify
        assertTrue(result);
        verify(log).info(contains("Client provided group id is"));
        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateStatusWithGeneratedGroupId() {
        // Setup
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        TClearhouseMaster chMsg = new TClearhouseMaster();
        chMsg.setIdI(123L);
        chMsgs.add(chMsg);

        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(new TAllocationGenericId());

        // Mock database sequence
        SqlRowSet mockRowSet = mock(SqlRowSet.class);
        when(mockRowSet.next()).thenReturn(true);
        when(mockRowSet.getString("GROUP_ID")).thenReturn("12345");
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(mockRowSet);

        // Mock update methods
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Execute
        boolean result = tmlApsCHFeedUtil.updateStatus(
            new MessageStatus("STATUS", "MSG"), 
            chMsgs, 
            container, 
            false
        );

        // Verify
        assertTrue(result);
        verify(tmlQueryDao).getRowSet(contains("DUAL"));
        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateChFeedStatus() {
        // Setup
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        for (int i = 1; i <= 1000; i++) {
            TClearhouseMaster chMsg = new TClearhouseMaster();
            chMsg.setIdI((long)i);
            chMsgs.add(chMsg);
        }

        AllocContainer container = new AllocContainer();

        // Mock subList behavior
        List<List<Long>> subLists = Arrays.asList(
            new ArrayList<>(),
            new ArrayList<>()
        );
        when(util.subList(anyList(), anyInt())).thenReturn(subLists);

        // Execute
        tmlApsCHFeedUtil.updateChFeedStatus("GROUP1", chMsgs, container);

        // Verify
        verify(util).subList(anyList(), eq(999));
        verify(tmlQueryDao, times(2)).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateMatchedStatusWithGroupId() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc1 = new TAllocationGenericId();
        alloc1.setIdI(1L);
        alloc1.setDownstreamStatusSW("NOT_MATCHED");
        container.addAsFillAndAvg(alloc1);

        TAllocationGenericId alloc2 = new TAllocationGenericId();
        alloc2.setIdI(2L);
        alloc2.setDownstreamStatusSW("MATCHED");
        container.addAsFillAndAvg(alloc2);

        // Mock database updates
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Execute
        tmlApsCHFeedUtil.updateMatchedStatus(
            "GROUP123", 
            new MessageStatus("Y", "Matched"), 
            container
        );

        // Verify
        verify(tmlQueryDao).updateWithInClause(contains("STATUS_QUERY"), anyMap());
        verify(tmlQueryDao).updateWithInClause(contains("ORDER_NUM_QRY"), anyMap());
    }

    @Test
    public void testUpdateAllocList() throws Exception {
        // Setup test data using reflection since method is private
        List<TAllocationGenericId> allocs = new ArrayList<>();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setIdI(1L);
        alloc.setDownstreamStatusSW("NOT_MATCHED");
        allocs.add(alloc);

        // Mock update
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Invoke private method via reflection
        Method method = TmlApsCHFeedUtil.class.getDeclaredMethod(
            "updateAllocList", 
            String.class, MessageStatus.class, List.class, String.class
        );
        method.setAccessible(true);
        method.invoke(
            tmlApsCHFeedUtil, 
            "GROUP1", 
            new MessageStatus("Y", "Matched"), 
            allocs, 
            "UPDATE_QUERY"
        );

        // Verify
        verify(tmlQueryDao).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateAllocGenericList() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setSourceIdI(123L);
        container.addAsFillAndAvg(alloc);

        // Mock update
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Invoke private method via reflection
        Method method = TmlApsCHFeedUtil.class.getDeclaredMethod(
            "updateAllocGenericList", 
            String.class, AllocContainer.class, String.class
        );
        method.setAccessible(true);
        method.invoke(tmlApsCHFeedUtil, "GROUP1", container, "UPDATE_QUERY");

        // Verify
        verify(tmlQueryDao).updateWithInClause(anyString(), anyMap());
        verify(log).info(contains("Allocation generic table got updated"));
    }

    @Test
    public void testUpdateCHList() throws Exception {
        // Setup
        List<Long> ids = Arrays.asList(1L, 2L, 3L);

        // Mock update
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(3);

        // Invoke private method via reflection
        Method method = TmlApsCHFeedUtil.class.getDeclaredMethod(
            "updateCHList", 
            String.class, List.class
        );
        method.setAccessible(true);
        method.invoke(tmlApsCHFeedUtil, "GROUP1", ids);

        // Verify
        verify(tmlQueryDao).updateWithInClause(contains("CH_FEED_QRY"), anyMap());
    }
}



@RunWith(MockitoJUnitRunner.class)
public class TmlApsCHFeedUtilTest {

    @InjectMocks
    private TmlApsCHFeedUtil util;

    @Mock
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private ImICollectionUtil imICollectionUtil;

    @Mock
    private SqlRowSet sqlRowSet;

    @Test
    public void testUpdateStatus_withClientProvidedGroupId() throws Exception {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientProvidedApsGrpIdC("123456");

        AllocContainer container = new AllocContainer();
        container.setFills(Collections.singletonList(alloc));
        List<TClearhouseMaster> chMsgs = Collections.singletonList(mock(TClearhouseMaster.class));

        MessageStatus status = new MessageStatus("SUCCESS", "Client provided test");

        boolean result = util.updateStatus(status, chMsgs, container, true);

        assertTrue(result);
    }

    @Test
    public void testUpdateStatus_withoutClientProvidedGroupId() throws Exception {
        TAllocationGenericId alloc = new TAllocationGenericId();

        AllocContainer container = new AllocContainer();
        container.setFills(Collections.singletonList(alloc));
        List<TClearhouseMaster> chMsgs = Collections.singletonList(mock(TClearhouseMaster.class));

        when(tmlQueryDao.getRowSet(anyString())).thenReturn(sqlRowSet);
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getString("GROUP_ID")).thenReturn("99999");

        MessageStatus status = new MessageStatus("SUCCESS", "No client group ID");

        boolean result = util.updateStatus(status, chMsgs, container, false);

        assertTrue(result);
    }

    @Test
    public void testPrivate_updateMatchedStatus_viaReflection() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setIdI(1L);
        alloc.setDownstreamStatusSw("NOT MATCHED");

        AllocContainer container = new AllocContainer();
        container.setFills(Collections.singletonList(alloc));

        MessageStatus status = new MessageStatus("DONE", "Private method test");

        ReflectionTestUtils.invokeMethod(util, "updateMatchedStatus", "GID12", status, container);

        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testPrivate_updateChFeedStatus_viaReflection() {
        TClearhouseMaster chm = mock(TClearhouseMaster.class);
        when(chm.getIdI()).thenReturn(123L);

        AllocContainer container = new AllocContainer();
        List<TClearhouseMaster> chList = Collections.singletonList(chm);

        // Reflectively call updateChFeedStatus
        ReflectionTestUtils.invokeMethod(util, "updateChFeedStatus", "GRP88", chList, container);

        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testPrivate_updateAllocGenericList_viaReflection() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setSourceIdI(BigDecimal.valueOf(456L));

        AllocContainer container = new AllocContainer();
        container.setAvg(Collections.singletonList(alloc));

        ReflectionTestUtils.invokeMethod(util, "updateAllocGenericList", "GRP77", container, "UPDATE QRY");

        verify(tmlQueryDao).updateWithInClause(anyString(), anyMap());
    }
}



@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {
    // ... other test methods ...

    @Test
    public void testUpdateMatchedStatus() {
        // Setup
        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(new TAllocationGenericId());
        
        // Solution 1: If you know the method returns int
        when(allocRepository.saveAllocProcesses(anyList())).thenReturn(1);
        
        // Solution 2: If you're not sure
        try {
            doNothing().when(allocRepository).saveAllocProcesses(anyList());
        } catch (org.mockito.exceptions.base.MockitoException e) {
            when(allocRepository.saveAllocProcesses(anyList())).thenReturn(1);
        }
        
        // Execute
        allocationService.updateMatchedStatus("Y", "Message", container);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
    }

    // ... other test methods ...
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Mock
    @Qualifier("gmiSchema")
    private String gmiSchema;

    private Logger log = Logger.getLogger(AllocationServiceImpl.class);

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Initialize broker enrichment map
        ConcurrentHashMap<String, String> brokerEnrichmentMap = new ConcurrentHashMap<>();
        brokerEnrichmentMap.put("EXCH_BROKER_MNEMONIC", "ENRICHED_VALUE");
        setPrivateField(allocationService, "brokerEnrichmentMap", brokerEnrichmentMap);
        
        // Set logger
        setPrivateField(allocationService, "log", log);
        
        when(gmiSchema).thenReturn("TEST_SCHEMA");
    }

    @Test
    public void testUpdateMatchedStatus() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        container.addAsFillAndAvg(alloc);
        
        // Correct mocking for void method
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.updateMatchedStatus("Y", "Test message", container);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
    }

    // Other test methods remain the same...

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Mock
    @Qualifier("gmiSchema")
    private String gmiSchema;

    private Logger log = Logger.getLogger(AllocationServiceImpl.class);

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Initialize broker enrichment map
        ConcurrentHashMap<String, String> brokerEnrichmentMap = new ConcurrentHashMap<>();
        brokerEnrichmentMap.put("EXCH_BROKER_MNEMONIC", "ENRICHED_VALUE");
        setPrivateField(allocationService, "brokerEnrichmentMap", brokerEnrichmentMap);
        
        // Set logger
        setPrivateField(allocationService, "log", log);
        
        when(gmiSchema).thenReturn("TEST_SCHEMA");
    }

    @Test
    public void testApplyEnrichment() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientC("MANAHL");
        alloc.setUnChangedexecBrkMneC("MNEMONIC");
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        
        // Execute
        allocationService.applyEnrichment(container, trnflFills);
        
        // Verify
        assertEquals("ENRICHED_VALUE", alloc.getBrokerEnrichment());
        verify(log).info(anyString());
    }

    @Test
    public void testIsOnlyEnrichment() throws Exception {
        // Test ALLOCATE case
        AllocContainer container1 = new AllocContainer();
        TAllocationGenericId alloc1 = new TAllocationGenericId();
        alloc1.setGmiMatchTypeC("ALLOCATE");
        container1.addAsFillAndAvg(alloc1);
        assertFalse(allocationService.isonlyEnrichment(container1));
        
        // Test UPDATE case
        AllocContainer container2 = new AllocContainer();
        TAllocationGenericId alloc2 = new TAllocationGenericId();
        alloc2.setGmiMatchTypeC("UPDATE");
        container2.addAsFillAndAvg(alloc2);
        assertTrue(allocationService.isonlyEnrichment(container2));
        
        // Test empty case
        assertTrue(allocationService.isonlyEnrichment(new AllocContainer()));
    }

    @Test
    public void testEnrichmentContainer() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientC("MANAHL");
        alloc.setGmiMatchTypeC("UPDATE");
        container.addAsFillAndAvg(alloc);
        
        List<String> ftraceL = Arrays.asList("TRACE1", "TRACE2");
        
        // Mock repository
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.enrichment(container, ftraceL);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
        verify(log, times(2)).info(anyString());
    }

    @Test
    public void testUpdateMatchedStatus() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        container.addAsFillAndAvg(alloc);
        
        // Mock repository
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.updateMatchedStatus("Y", "Test message", container);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
    }

    @Test
    public void testFrefnoEnrichment() throws Exception {
        // Setup
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setOrderOrigC("ORIG1234567890"); // 12 chars
        List<String> ftraceL = Arrays.asList("TRACE1");
        Map<String, String> extidMap = new HashMap<>();
        
        // Mock DAO
        when(gmiQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);
        
        // Execute
        allocationService.frefnoEnrichment(alloc, ftraceL, extidMap);
        
        // Verify
        verify(gmiQueryDao).updateWithInClause(anyString(), anyMap());
        verify(log).info(contains("New value: ORIG12345678"));
    }

    @Test
    public void testBrokerEnrichment() throws Exception {
        // Setup
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setUnChangedexecBrkMneC("MNEMONIC");
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER");
        alloc.setGmiMatchTypeC("UPDATE");
        List<String> ftraceL = Arrays.asList("TRACE1");
        
        // Mock DAO
        when(gmiQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);
        
        // Execute
        allocationService.brokerEnrichment(alloc, ftraceL, null);
        
        // Verify
        verify(gmiQueryDao).updateWithInClause(anyString(), anyMap());
        verify(log).info(contains("broker enrichment for"));
    }

    @Test
    public void testSaveTracesInTml() throws Exception {
        // Setup
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientC("TEST");
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setId(123L);
        List<String> ftraceL = Arrays.asList("TRACE1");
        
        // Mock repository
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.saveTracesInTml(ftraceL, alloc);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
        verify(log).info(contains("request to add ftrace"));
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

@Test
public void testFrefnoEnrichmentWithNullOrderOrig() throws Exception {
    TAllocationGenericId alloc = new TAllocationGenericId();
    alloc.setOrderOrigC(null);
    List<String> ftraceL = Arrays.asList("TRACE1");
    
    allocationService.frefnoEnrichment(alloc, ftraceL, null);
    
    verify(log).info(contains("frefno should not be empty"));
    verify(allocRepository).saveAllocProcesses(anyList());
}

@Test
public void testSaveListLargeBatch() throws Exception {
    List<TAllocGmiRef> largeList = new ArrayList<>();
    for (int i = 0; i < 1000; i++) {
        TAllocGmiRef ref = new TAllocGmiRef();
        largeList.add(ref);
    }
    
    // Mock repository
    doNothing().when(allocRepository).saveAllocProcesses(anyList());
    
    allocationService.saveList(largeList);
    
    // Verify it handles large batches by splitting
    verify(allocRepository, atLeast(2)).saveAllocProcesses(anyList());
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessByEachAlloc() {
        // 1. Create test allocation with all required fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        Map<String, AllocContainer> mockMap = new HashMap<>();
        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(alloc);
        mockMap.put("GROUP1", container);
        
        // 2. Mock GMI response
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        fill.setFfc(alloc.getGmiInstTypeC());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(mockTrnflFills);
        
        // 3. Execute via reflection since processAllocs is private
        invokeProcessAllocs(TmlInternalApsJobs.jobs.EACH_FILL, mockMap);
        
        // 4. Verify
        verify(gmiQueryDao).queryForRowMapper(anyString(), any(Map.class), any());
    }

    @Test
    public void testProcessByEachAllocWithNullAccounts() {
        // 1. Create test allocation with null account fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        alloc.setAcctMatchOnC("M"); // Requires matchAcctC
        alloc.setMatchAcctC(null); // Explicitly null
        
        Map<String, AllocContainer> mockMap = new HashMap<>();
        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(alloc);
        mockMap.put("GROUP1", container);
        
        // 2. Should handle null accounts gracefully
        invokeProcessAllocs(TmlInternalApsJobs.jobs.EACH_FILL, mockMap);
        
        // 3. Verify warning was logged
        verify(allocationService.log).warn(contains("fills not found"));
    }

    private TAllocationGenericId createCompleteTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        // Required fields
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        
        // Account fields
        alloc.setAcctMatchOnC("C"); // Default to clearing account
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setMatchAcctC("MATCH_ACCT");
        alloc.setExecutionAcctC("EXEC_ACCT");
        
        // Other required fields
        alloc.setTradeDateD(new Date());
        alloc.setGmiExchCdC("TEST_EXCH");
        alloc.setGmiInstTypeC("FUT");
        alloc.setExecBrkMneC("EXEC_BRK");
        alloc.setBs("B");
        alloc.setSilentBrokerC("BROKER1");
        
        return alloc;
    }

    private void invokeProcessAllocs(TmlInternalApsJobs.jobs job, Map<String, AllocContainer> map) {
        try {
            Method method = AllocationServiceImpl.class.getDeclaredMethod(
                "processAllocs", 
                TmlInternalApsJobs.jobs.class, Map.class);
            method.setAccessible(true);
            method.invoke(allocationService, job, map);
        } catch (Exception e) {
            throw new RuntimeException("Failed to invoke processAllocs", e);
        }
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessByEachAlloc() {
        // 1. Create test allocation with ALL required fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO response
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI response
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processByEachAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    private TAllocationGenericId createCompleteTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        // Required fields
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        
        // Account fields required for getGmiLookUpAc
        alloc.setAcctMatchOnC("C"); // or "M"/"E" depending on your needs
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setMatchAcctC("MATCH_ACCT"); // If using match account
        alloc.setExecutionAcctC("EXEC_ACCT"); // If using exec account
        
        // Other required fields
        alloc.setTradeDateD(new Date());
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER1");
        
        return alloc;
    }

    @Test
    public void testGetGmiLookUpAc() {
        // Test all account matching scenarios
        List<TAllocationGenericId> fills = new ArrayList<>();
        
        // Clearing account case
        TAllocationGenericId alloc1 = createCompleteTestAllocation();
        alloc1.setAcctMatchOnC("C");
        alloc1.setClearingAcctC("CLEARING_ACCT");
        fills.add(alloc1);
        
        // Match account case
        TAllocationGenericId alloc2 = createCompleteTestAllocation();
        alloc2.setAcctMatchOnC("M");
        alloc2.setMatchAcctC("MATCH_ACCT");
        fills.add(alloc2);
        
        // Execution account case
        TAllocationGenericId alloc3 = createCompleteTestAllocation();
        alloc3.setAcctMatchOnC("E");
        alloc3.setExecutionAcctC("EXEC_ACCT");
        fills.add(alloc3);
        
        // Default case
        TAllocationGenericId alloc4 = createCompleteTestAllocation();
        alloc4.setAcctMatchOnC(null);
        alloc4.setClearingAcctC("DEFAULT_ACCT");
        fills.add(alloc4);
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(4, result.size());
        assertTrue(result.contains("CLEARING_ACCT"));
        assertTrue(result.contains("MATCH_ACCT"));
        assertTrue(result.contains("EXEC_ACCT"));
        assertTrue(result.contains("DEFAULT_ACCT"));
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

@Test
public void testProcessByEachAlloc() {
    // Given
    TAllocationGenericId testAlloc = createTestAllocation("GROUP1", "100.50");
    List<TAllocationGenericId> mockAllocations = Collections.singletonList(testAlloc);

    AllocContainer mockContainer = mock(AllocContainer.class);
    when(mockContainer.getFills()).thenReturn(mockAllocations);

    Map<String, AllocContainer> allocMap = new HashMap<>();
    allocMap.put("GROUP1", mockContainer);

    // Stub DAO call
    when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class))
    ).thenReturn(mockAllocations);

    // Stub getGmiLookUpAC if needed
    when(allocationService.getGmiLookUpAC(anyList())).thenReturn(mock(LookUpAC.class));

    // Optionally stub methods like checkForEachFillExistInGMI if they're not real
    doReturn(true).when(allocationService).checkForEachFillExistInGMI(
            anyList(), anyList(), anyList(), any()
    );

    // Inject the mocked map into the private method using reflection (if needed)
    ReflectionTestUtils.invokeMethod(
        allocationService,
        "processAllocs",
        TmlInternalApsJobs.jobs.BACH_FILL,
        allocMap
    );

    // Then
    verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class)
    );
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final SimpleDateFormat tradeDtFormat = new SimpleDateFormat("yyyyMMdd");
    private static final SimpleDateFormat matDtFormat = new SimpleDateFormat("yyyyMMdd");
    private static final SimpleDateFormat matDayFormat = new SimpleDateFormat("dd");

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Initialize formats
        setPrivateField(allocationService, "tradeDtFormat", tradeDtFormat);
        setPrivateField(allocationService, "matDtFormat", matDtFormat);
        setPrivateField(allocationService, "matDayFormat", matDayFormat);
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC("TEST_EXCH"); // Set exchange code
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        fill.setFfc(alloc.getGmiInstTypeC());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Mock GMI query response
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(trnflFills);
        
        // 5. Invoke via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 6. Verify
        assertTrue("Fills should match allocations", result);
    }

    @Test
    public void testCheckIfFillsSumMatchesWithNullExchange() throws Exception {
        // 1. Create test data with null exchange code
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC(null); // Null exchange code
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Should handle null exchange code gracefully
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 3. Invoke via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 4. Verify
        assertFalse("Should return false with null exchange code", result);
    }

    @Test
    public void testProcessBySumAllocWithExchangeCheck() {
        // 1. Create test data with exchange code
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC("TEST_EXCH");
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI response with matching exchange code
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setMaturityDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        alloc.setGmiExchCdC("TEST_EXCH");
        alloc.setGmiInstTypeC("FUT");
        alloc.setExecBrkMneC("EXEC_BRK");
        alloc.setBs("B");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessBySumAlloc() {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI check to return matching fills
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
        
        verify(gmiQueryDao, atLeastOnce()).queryForRowMapper(
            anyString(), any(Object[].class), any());
    }

    @Test
    public void testProcessBySumAllocWithNullFills() {
        // 1. Create valid test allocation
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO to return our test allocation
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI to return empty list (no matching fills)
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(Collections.emptyList());
        
        // 4. Execute - should handle null fills gracefully
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Invoke directly via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 5. Verify
        assertTrue("Fills should match allocations", result);
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessBySumAlloc() {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI check to return matching fills
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
        
        verify(gmiQueryDao, atLeastOnce()).queryForRowMapper(
            anyString(), any(Object[].class), any());
    }

    @Test
    public void testProcessBySumAllocWithNullFills() {
        // 1. Create valid test allocation
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO to return our test allocation
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI to return empty list (no matching fills)
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(Collections.emptyList());
        
        // 4. Execute - should handle null fills gracefully
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Invoke directly via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 5. Verify
        assertTrue("Fills should match allocations", result);
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0)) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessBySumAlloc() {
        // Create test allocation with all required fields
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.50");
        alloc.setAcctMatchOnC("C"); // Set account matching type
        alloc.setClearingAcctC("CLEARING_ACCT"); // Set required account field
        
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // Mock GMI check to return some dummy data
        List<Gmitrnfl> dummyTrnflFills = new ArrayList<>();
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(dummyTrnflFills);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocWithNullAccounts() {
        // Create test allocation with null account fields
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.50");
        alloc.setAcctMatchOnC("M"); // Matching type that requires matchAcctC
        // Intentionally not setting matchAcctC to test null handling
        
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // Should handle null accounts gracefully
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testGetGmiLookUpAcWithDifferentAccountTypes() {
        List<TAllocationGenericId> fills = new ArrayList<>();
        
        // Clearing account
        TAllocationGenericId alloc1 = createTestAllocation("GROUP1", "100.00");
        alloc1.setAcctMatchOnC("C");
        alloc1.setClearingAcctC("CLEARING_ACCT");
        fills.add(alloc1);
        
        // Match account
        TAllocationGenericId alloc2 = createTestAllocation("GROUP2", "200.00");
        alloc2.setAcctMatchOnC("M");
        alloc2.setMatchAcctC("MATCH_ACCT");
        fills.add(alloc2);
        
        // Execution account
        TAllocationGenericId alloc3 = createTestAllocation("GROUP3", "300.00");
        alloc3.setAcctMatchOnC("E");
        alloc3.setExecutionAcctC("EXEC_ACCT");
        fills.add(alloc3);
        
        // Default case
        TAllocationGenericId alloc4 = createTestAllocation("GROUP4", "400.00");
        alloc4.setAcctMatchOnC(null);
        alloc4.setClearingAcctC("DEFAULT_ACCT");
        fills.add(alloc4);
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(4, result.size());
        assertTrue(result.contains("CLEARING_ACCT"));
        assertTrue(result.contains("MATCH_ACCT"));
        assertTrue(result.contains("EXEC_ACCT"));
        assertTrue(result.contains("DEFAULT_ACCT"));
    }

    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }
}






import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // EXACT SQL query from your production code
    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0)) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByEachAlloc() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        // EXACT mock setup matching production call
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processByEachAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processBySumAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class));
    }

    // Helper method to create test allocations
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    @Test
    public void testEmptyAllocations() {
        // Given
        when(tmlQueryDao.queryForRowMapper(
            anyString(), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(Collections.emptyList());
        
        // When
        allocationService.processByEachAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test(expected = RuntimeException.class)
    public void testDaoExceptionHandling() {
        // Given
        when(tmlQueryDao.queryForRowMapper(
            anyString(), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenThrow(new RuntimeException("Database error"));
        
        // When
        allocationService.processByEachAlloc();
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.RowMapper;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // Actual SQL query from production code
    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS " +
        "WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " +
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RIS', 'NMY') " +
        "ORDER BY id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByEachAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        // Mock with the exact SQL query and proper mapper
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByEachAlloc();
        
        // Verify the exact SQL was used with proper mapper
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(),
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(),
            any(TAllocationProcessMapper.class));
    }

    // Helper method to create test allocations
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.RowMapper;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // Constants that should match your production code
    private static final String EACH_ALLOC_SQL = "SELECT * FROM allocations";
    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";
    private static final String UPDATE_ALLOCATION_STATUS_QUERY = "UPDATE allocations SET status = ?";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    // Use real String instead of mock
    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        
        // Initialize broker enrichment map
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
        
        // Initialize the service
        allocationService.init();
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByBachAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(eq(EACH_ALLOC_SQL), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByBachAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(eq(EACH_ALLOC_SQL), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(eq(SUM_BY_ALLOC_SQL), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(eq(SUM_BY_ALLOC_SQL), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(RowMapper.class));
    }

    @Test
    public void testGetGmiLookUpAc() {
        List<TAllocationGenericId> fills = Arrays.asList(
            createTestAllocationWithAccount("C", "ACCT1", null, null),
            createTestAllocationWithAccount("M", null, "ACCT2", null),
            createTestAllocationWithAccount("E", null, null, "ACCT3")
        );
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(3, result.size());
        assertTrue(result.contains("ACCT1"));
        assertTrue(result.contains("ACCT2"));
        assertTrue(result.contains("ACCT3"));
    }

    @Test
    public void testCalcAvgPxIfNoPxMatch() throws Exception {
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.00");
        alloc.setIsGmiPriceMatch("N");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = Arrays.asList(
            createGmiTrnFl(100, "110.00"),
            createGmiTrnFl(100, "90.00")
        );
        
        allocationService.calcAvgPxIfNoPxMatch(container, trnflFills);
        
        assertEquals(new BigDecimal("100.00"), container.getAvg().get(0).getPriceD());
    }

    // Helper methods
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private TAllocationGenericId createTestAllocationWithAccount(
            String matchType, String clearingAcct, String matchAcct, String execAcct) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setAcctMatchOnC(matchType);
        alloc.setClearingAcctC(clearingAcct);
        alloc.setMatchAcctC(matchAcct);
        alloc.setExecutionAcctC(execAcct);
        return alloc;
    }

    private Gmitrnfl createGmiTrnFl(int qty, String price) {
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(qty);
        fill.setFtpric(new BigDecimal(price));
        return fill;
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    // Use real String instead of mock
    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        
        // Initialize broker enrichment map
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
        
        // Initialize the service
        allocationService.init();
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByBatchAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(anyString(), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByBatchAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(anyString(), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(anyString(), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(anyString(), isNull(), any(RowMapper.class));
    }

    @Test
    public void testGetGmiLookUpAc() {
        List<TAllocationGenericId> fills = Arrays.asList(
            createTestAllocationWithAccount("C", "ACCT1", null, null),
            createTestAllocationWithAccount("M", null, "ACCT2", null),
            createTestAllocationWithAccount("E", null, null, "ACCT3")
        );
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(3, result.size());
        assertTrue(result.contains("ACCT1"));
        assertTrue(result.contains("ACCT2"));
        assertTrue(result.contains("ACCT3"));
    }

    @Test
    public void testCalcAvgPxIfNoPxMatch() throws Exception {
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.00");
        alloc.setIsGmiPriceMatch("N");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = Arrays.asList(
            createGmiTrnFl(100, "110.00"),
            createGmiTrnFl(100, "90.00")
        );
        
        allocationService.calcAvgPxIfNoPxMatch(container, trnflFills);
        
        assertEquals(new BigDecimal("100.00"), container.getAvg().get(0).getPriceD());
    }

    // Helper methods
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private TAllocationGenericId createTestAllocationWithAccount(
            String matchType, String clearingAcct, String matchAcct, String execAcct) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setAcctMatchOnC(matchType);
        alloc.setClearingAcctC(clearingAcct);
        alloc.setMatchAcctC(matchAcct);
        alloc.setExecutionAcctC(execAcct);
        return alloc;
    }

    private Gmitrnfl createGmiTrnFl(int qty, String price) {
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(qty);
        fill.setFtpric(new BigDecimal(price));
        return fill;
    }

    // Add other test methods as needed...
}


@Test
public void testProcessBySumAllocByBroker() {
    // Setup test data
    List<TAllocationGenericId> mockAllocations = new ArrayList<>();
    TAllocationGenericId alloc = new TAllocationGenericId();
    alloc.setTmlAllocGroupIdC("GROUP1");
    alloc.setPriceD(new BigDecimal("100.50"));
    alloc.setSilentBrokerC("BROKER1");
    mockAllocations.add(alloc);

    // Mock the queryForRowMapper call with proper argument types
    when(tmlQueryDao.queryForRowMapper(
        eq(BROKER_SUM_BY_ALLOC_SQL),  // or anyString() if you prefer
        isNull(Object[].class),
        any(RowMapper.class)))  // Changed from TAllocationProcessMapper.class
        .thenReturn(mockAllocations);

    // Execute
    allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);

    // Verify
    verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(
        eq(BROKER_SUM_BY_ALLOC_SQL),  // or anyString()
        isNull(Object[].class),
        any(RowMapper.class));
    verify(log, atLeastOnce()).info(anyString());
}


import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.*;
import java.math.BigDecimal;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.StringUtil;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() {
        allocationService = new AllocationServiceImpl();
        MockitoAnnotations.initMocks(this);

        allocationService.tmlQueryDao = tmlQueryDao;
        allocationService.gmiQueryDao = gmiQueryDao;
        allocationService.allocRepository = allocRepository;
        allocationService.gmiSchema = "TEST_SCHEMA";
    }

    @Test
    public void testProcessByBatchAlloc() throws Exception {
        List<TAllocationGenericId> dummyList = Collections.singletonList(mock(TAllocationGenericId.class));
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(dummyList);

        allocationService.processByBachAlloc();

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testProcessBySumAlloc() throws Exception {
        List<TAllocationGenericId> dummyList = Collections.singletonList(mock(TAllocationGenericId.class));
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(dummyList);

        allocationService.processBySumAlloc();

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testProcessBySumAllocByBroker_withEmptyAllocations() throws Exception {
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(Collections.emptyList());

        allocationService.processBySumAllocByBroker(ImlAllocationJobs.jobs.SUM_FILL_BROKER);

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testGetGmiLookUpAc() {
        TAllocationGenericId allocation = mock(TAllocationGenericId.class);
        when(allocation.getAcctMatchOnC()).thenReturn("M");
        when(allocation.getMatchAcctC()).thenReturn("MATCH123");

        List<TAllocationGenericId> allocations = Arrays.asList(allocation);
        List<String> result = allocationService.getGmiLookUpAc(allocations);

        assertEquals(1, result.size());
        assertTrue(result.contains("MATCH123"));
    }

    @Test
    public void testAddFtype_WhenCMEGroup() {
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getGmiExchCdC()).thenReturn("CME");

        String result = allocationService.addFtype(alloc, "first", "withFtype");
        assertNotNull(result);
    }

    @Test
    public void testAddFtpric_WhenPriceNotMatched() {
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getClientC()).thenReturn("MOORECAP");
        when(alloc.getIsGmiPriceMatch()).thenReturn("N");

        allocationService.currentJob = ImlAllocationJobs.jobs.SUM_FILL_BROKER_NO_PRICE;

        String result = allocationService.addFtpric(alloc, "withFtpric");
        assertNotNull(result);
    }
}
