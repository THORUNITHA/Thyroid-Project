 import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.jdbc.support.rowset.SqlRowSet;

import com.baml.tml.tmlaps.model.MessageStatus;
import com.baml.tml.tmlaps.onExchange.service.TmlOnExchangeApsService;
import com.baml.tml.tmlbase.trade.model.AllocContainer;
import com.baml.tml.tmlbase.trade.persistence.dao.TAllocationGenericId;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;
import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;

@RunWith(MockitoJUnitRunner.class)
public class TmlOnExchangeApsServiceImplTest {

    @Mock
    private QueryDaoJdbc tmlQueryDao;
    
    @Mock
    private Logger log;
    
    @Mock
    private SqlRowSet rowSet;
    
    @InjectMocks
    private TmlOnExchangeApsServiceImpl service = new TmlOnExchangeApsServiceImpl();
    
    private Map<String, AllocContainer> testContainerMap;
    
    @Before
    public void setUp() throws Exception {
        // Initialize test data
        testContainerMap = new HashMap<>();
        
        // Set up mock behavior for logger
        Logger realLogger = Logger.getLogger(TmlOnExchangeApsServiceImpl.class);
        when(log.isInfoEnabled()).thenReturn(true);
        when(log.isWarnEnabled()).thenReturn(true);
        when(log.isErrorEnabled()).thenReturn(true);
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithValidContainer() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId fill1 = new TAllocationGenericId();
        fill1.setPrice(10.0);
        fill1.setQty(100);
        container.setFills(Arrays.asList(fill1));
        
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(10.0);
        avg1.setQty(100);
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start processByReplayPartialGroups()");
        verify(log).info(contains("REPLAY FILL SQL query="));
        verify(log).info("Start updating match status N to RTS.");
        verify(log).info("Completed processByReplayPartialGroups()");
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithOnlyAvg() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(10.0);
        avg1.setQty(100);
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).warn(contains(":no Fills:"));
        verify(log, never()).info("Start updating match status N to RTS.");
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithPriceQtyMismatch() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId fill1 = new TAllocationGenericId();
        fill1.setPrice(10.0);
        fill1.setQty(100);
        container.setFills(Arrays.asList(fill1));
        
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(20.0); // Different price
        avg1.setQty(100);
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).warn(contains("still doesn't match fills against avg trades sum(price*qty)"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithEmptyContainerMap() {
        // Setup
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start processByReplayPartialGroups()");
        verify(log).info("Completed processByReplayPartialGroups()");
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithDatabaseException() {
        // Setup
        when(tmlQueryDao.getRowSet(anyString())).thenThrow(new RuntimeException("DB Error"));
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).error(contains("error occurred while processing replay partial groups"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithNullContainer() {
        // Setup
        testContainerMap.put("TEST_KEY", null);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).error(contains("Null container found for key"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithEmptyFillsAndAvg() {
        // Setup
        AllocContainer container = new AllocContainer();
        container.setFills(new ArrayList<>());
        container.setAvg(new ArrayList<>());
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).warn(contains(":no Fills:"));
    }
    
    @Test
    public void testProcessByReplayPartialGroups_WithMultipleFillsAndAvg() {
        // Setup
        AllocContainer container = new AllocContainer();
        
        // Create fills
        TAllocationGenericId fill1 = new TAllocationGenericId();
        fill1.setPrice(10.0);
        fill1.setQty(100);
        
        TAllocationGenericId fill2 = new TAllocationGenericId();
        fill2.setPrice(10.0);
        fill2.setQty(50);
        
        container.setFills(Arrays.asList(fill1, fill2));
        
        // Create avg
        TAllocationGenericId avg1 = new TAllocationGenericId();
        avg1.setPrice(10.0);
        avg1.setQty(150); // Sum of fills qty
        container.setAvg(Arrays.asList(avg1));
        
        testContainerMap.put("TEST_KEY", container);
        
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(rowSet);
        when(rowSet.next()).thenReturn(false); // No more rows
        
        // Test
        service.processByReplayPartialGroups();
        
        // Verify
        verify(log).info("Start updating match status N to RTS.");
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.PropertyException;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.jdbc.support.rowset.SqlRowSet;

@RunWith(MockitoJUnitRunner.class)
public class TmlApsExchangeConnectorServiceImplTest {

    @Mock
    private TClearhouseMasterDao tClearhouseMasterDao;
    
    @Mock
    private SqlRowSet rowSet;
    
    @Mock
    private SqlRowSet rowSetAvg;
    
    @InjectMocks
    private TmlApsExchangeConnectorServiceImpl service;
    
    private List<TClearhouseMaster> mockMasterList;
    private TClearhouseMaster mockMaster;
    
    @Before
    public void setUp() {
        mockMaster = new TClearhouseMaster();
        mockMaster.setId(123L);
        mockMaster.setExchangeCdC("EXCH1");
        mockMaster.setApsGroupIdC("GROUP1");
        
        mockMasterList = new ArrayList<>();
        mockMasterList.add(mockMaster);
    }

    @Test
    public void testProcessToCompleteApsGroup_HappyPath() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("VALID_CLIENT");
        
        // Mock average price response
        when(rowSetAvg.next()).thenReturn(true).thenReturn(false);
        when(rowSetAvg.getBigDecimal("AVERAGE_PRICE_D")).thenReturn(new BigDecimal("100.50"));
        when(tClearhouseMasterDao.getAvgPriceGroupCompletion(anyString(), anyLong())).thenReturn(rowSetAvg);
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify interactions
        verify(tClearhouseMasterDao).completeApsGroup("EXCH1", "GROUP1");
        verify(tClearhouseMasterDao).updateGenericAvgPriceList(any(BigDecimal.class), eq("GROUP1"));
    }

    @Test
    public void testProcessToCompleteApsGroup_EmptyClientName() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses with empty client name
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("");
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no message was sent
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }

    @Test
    public void testProcessToCompleteApsGroup_NullClientName() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses with null client name
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn(null);
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no message was sent
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }

    @Test
    public void testProcessToCompleteApsGroup_ClientInExclusionList() throws Exception {
        // Set up exclusion list
        service.avgNotReqString = "EXCLUDED_CLIENT,ANOTHER_CLIENT";
        
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock DAO responses with excluded client
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockMasterList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("EXCLUDED_CLIENT");
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no message was sent
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }

    @Test
    public void testProcessToCompleteApsGroup_EmptyMasterList() throws Exception {
        // Mock rowset with data
        when(rowSet.next()).thenReturn(true).thenReturn(false);
        when(rowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(rowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(rowSet.getLong("LOTS")).thenReturn(100L);
        
        // Mock empty master list
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(rowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(new ArrayList<>());
        
        // Execute
        service.processToCompleteApsGroup();
        
        // Verify no interactions with message sending
        verify(tClearhouseMasterDao, never()).updateGenericAvgPriceList(any(), any());
    }
}



import org.springframework.test.util.ReflectionTestUtils;

@Test
public void testGetQ_WithSpringUtils() {
    // Setup
    mockMaster.setExchangeCdC("IFUS");
    mockMaster.setDestIdC("DEST1");
    
    Map<String, String> queues = new HashMap<>();
    queues.put("IFUS.DEST1", "TEST.QUEUE");
    
    // Set private field
    ReflectionTestUtils.setField(service, "outBoundQueues", queues);
    
    // Invoke private method
    String result = ReflectionTestUtils.invokeMethod(service, "getQ", mockMaster);
    
    assertEquals("TEST.QUEUE", result);
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.jms.JMSException;
import javax.xml.bind.JAXBException;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.jdbc.support.rowset.SqlRowSet;

import com.baml.tml.tmlbase.trade.clearhouse.fixml.Fixml;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMaster;
import com.baml.tml.tmlbase.trade.persistence.dao.TClearhouseMasterDao;
import com.baml.tml.tmlbase.trade.util.FileMessage;
import com.baml.tml.tmlbase.trade.util.TmlMqMessageWriter;

@RunWith(MockitoJUnitRunner.class)
public class TmlApsExchangeConnectorServiceImplTest {

    @Mock
    private TClearhouseMasterDao tClearhouseMasterDao;
    
    @Mock
    private TmlMqMessageWriter tmlMqMessageWriter;
    
    @Mock
    private FileMessage fileMessage;
    
    @Mock
    private Map<String, String> outBoundQueues;
    
    @Mock
    private Logger log;
    
    @InjectMocks
    private TmlApsExchangeConnectorServiceImpl service;
    
    private TClearhouseMaster mockMaster;
    private List<TClearhouseMaster> mockList;
    
    @Before
    public void setUp() {
        mockMaster = new TClearhouseMaster();
        mockMaster.setId(123L);
        mockMaster.setExchangeCdC("EXCH1");
        mockMaster.setDestIdC("DEST1");
        mockMaster.setApsGroupIdC("GROUP1");
        
        mockList = new ArrayList<>();
        mockList.add(mockMaster);
    }

    @Test
    public void testProcessMatchedMsgs_EmptyList() throws JAXBException, JMSException {
        when(tClearhouseMasterDao.listClearHouseMaster()).thenReturn(new ArrayList<>());
        
        service.processMatchedMsgs();
        
        verify(tClearhouseMasterDao).listClearHouseMaster();
        verifyNoMoreInteractions(tClearhouseMasterDao, tmlMqMessageWriter, fileMessage);
    }

    @Test
    public void testProcessMatchedMsgs_WithRecords() throws JAXBException, JMSException {
        when(tClearhouseMasterDao.listClearHouseMaster()).thenReturn(mockList);
        when(outBoundQueues.get(anyString())).thenReturn("TEST.QUEUE");
        
        service.processMatchedMsgs();
        
        verify(tClearhouseMasterDao).listClearHouseMaster();
        verify(tClearhouseMasterDao).updateMatchedStatus(anyList(), eq("S"));
        verify(fileMessage).writeMessageToFile(anyString());
        verify(tmlMqMessageWriter).sendMessage(anyString(), anyString());
    }

    @Test
    public void testProcessToCompleteApsGroup() throws PropertyException, JAXBException, JMSException {
        SqlRowSet mockRowSet = mock(SqlRowSet.class);
        when(mockRowSet.next()).thenReturn(true).thenReturn(false);
        when(mockRowSet.getString("EXCHANGE_CD_C")).thenReturn("EXCH1");
        when(mockRowSet.getString("APS_GROUP_ID_C")).thenReturn("GROUP1");
        when(mockRowSet.getLong("LOTS")).thenReturn(100L);
        
        when(tClearhouseMasterDao.qtyByGroup()).thenReturn(mockRowSet);
        when(tClearhouseMasterDao.listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString()))
            .thenReturn(mockList);
        when(tClearhouseMasterDao.getClientName(anyString())).thenReturn("CLIENT1");
        when(outBoundQueues.get(anyString())).thenReturn("TEST.QUEUE");
        
        SqlRowSet mockAvgRowSet = mock(SqlRowSet.class);
        when(mockAvgRowSet.next()).thenReturn(true).thenReturn(false);
        when(mockAvgRowSet.getBigDecimal("AVERAGE_PRICE_D")).thenReturn(new BigDecimal("100.50"));
        when(tClearhouseMasterDao.getAvgPriceGroupCompletion(anyString(), anyLong())).thenReturn(mockAvgRowSet);
        
        service.processToCompleteApsGroup();
        
        verify(tClearhouseMasterDao).qtyByGroup();
        verify(tClearhouseMasterDao).listMatchedHQLApsGroupClearHouseMaster(anyString(), anyLong(), anyString());
        verify(tClearhouseMasterDao).getClientName(anyString());
        verify(tClearhouseMasterDao).getAvgPriceGroupCompletion(anyString(), anyLong());
        verify(tClearhouseMasterDao).updateGenericAvgPriceList(any(BigDecimal.class), anyString());
        verify(tClearhouseMasterDao).completeApsGroup(anyString(), anyString());
        verify(fileMessage).writeMessageToFile(anyString());
        verify(tmlMqMessageWriter).sendMessage(anyString(), anyString());
    }

    @Test
    public void testGetQ_WithDestId() {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setExchangeCdC("IFUS");
        master.setDestIdC("DEST1");
        
        Map<String, String> queues = new HashMap<>();
        queues.put("IFUS.DEST1", "TEST.QUEUE");
        service.outBoundQueues = queues;
        
        String result = service.getQ(master);
        assertEquals("TEST.QUEUE", result);
    }

    @Test
    public void testGetQ_WithoutDestId() {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setExchangeCdC("EXCH1");
        
        Map<String, String> queues = new HashMap<>();
        queues.put("EXCH1", "TEST.QUEUE");
        service.outBoundQueues = queues;
        
        String result = service.getQ(master);
        assertEquals("TEST.QUEUE", result);
    }

    @Test
    public void testGetQ_NoQueueConfigured() {
        TClearhouseMaster master = new TClearhouseMaster();
        master.setExchangeCdC("UNKNOWN");
        
        Map<String, String> queues = new HashMap<>();
        service.outBoundQueues = queues;
        
        String result = service.getQ(master);
        assertNull(result);
    }

    @Test
    public void testUpdateStatus() {
        List<Long> ids = Arrays.asList(1L, 2L, 3L);
        service.updateStatus(ids, "S");
        verify(tClearhouseMasterDao).updateMatchedStatus(ids, "S");
    }

    @Test
    public void testWriteMsgToExchange() throws JMSException {
        when(outBoundQueues.get(anyString())).thenReturn("TEST.QUEUE");
        
        service.writeMsgToExchange(mockMaster, "<test>message</test>");
        
        verify(fileMessage).writeMessageToFile(anyString());
        verify(tmlMqMessageWriter).sendMessage(anyString(), anyString());
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.sql.SQLException;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.support.rowset.SqlRowSet;

@RunWith(MockitoJUnitRunner.class)
public class TmlApsCHFeedUtilTest {

    @InjectMocks
    private TmlApsCHFeedUtil tmlApsCHFeedUtil;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private Logger log;

    @Mock
    private ImlCollectionUtil util;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // Inject mock logger via reflection if needed
    }

    @Test
    public void testUpdateStatusWithClientProvidedGroupId() {
        // Setup
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        TClearhouseMaster chMsg = new TClearhouseMaster();
        chMsg.setIdI(123L);
        chMsgs.add(chMsg);

        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientProvidedApsGrpIdC("CLIENT12345");
        container.addAsFillAndAvg(alloc);

        // Mock behavior
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Execute
        boolean result = tmlApsCHFeedUtil.updateStatus(
            new MessageStatus("STATUS", "MSG"), 
            chMsgs, 
            container, 
            true
        );

        // Verify
        assertTrue(result);
        verify(log).info(contains("Client provided group id is"));
        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateStatusWithGeneratedGroupId() {
        // Setup
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        TClearhouseMaster chMsg = new TClearhouseMaster();
        chMsg.setIdI(123L);
        chMsgs.add(chMsg);

        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(new TAllocationGenericId());

        // Mock database sequence
        SqlRowSet mockRowSet = mock(SqlRowSet.class);
        when(mockRowSet.next()).thenReturn(true);
        when(mockRowSet.getString("GROUP_ID")).thenReturn("12345");
        when(tmlQueryDao.getRowSet(anyString())).thenReturn(mockRowSet);

        // Mock update methods
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Execute
        boolean result = tmlApsCHFeedUtil.updateStatus(
            new MessageStatus("STATUS", "MSG"), 
            chMsgs, 
            container, 
            false
        );

        // Verify
        assertTrue(result);
        verify(tmlQueryDao).getRowSet(contains("DUAL"));
        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateChFeedStatus() {
        // Setup
        List<TClearhouseMaster> chMsgs = new ArrayList<>();
        for (int i = 1; i <= 1000; i++) {
            TClearhouseMaster chMsg = new TClearhouseMaster();
            chMsg.setIdI((long)i);
            chMsgs.add(chMsg);
        }

        AllocContainer container = new AllocContainer();

        // Mock subList behavior
        List<List<Long>> subLists = Arrays.asList(
            new ArrayList<>(),
            new ArrayList<>()
        );
        when(util.subList(anyList(), anyInt())).thenReturn(subLists);

        // Execute
        tmlApsCHFeedUtil.updateChFeedStatus("GROUP1", chMsgs, container);

        // Verify
        verify(util).subList(anyList(), eq(999));
        verify(tmlQueryDao, times(2)).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateMatchedStatusWithGroupId() {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc1 = new TAllocationGenericId();
        alloc1.setIdI(1L);
        alloc1.setDownstreamStatusSW("NOT_MATCHED");
        container.addAsFillAndAvg(alloc1);

        TAllocationGenericId alloc2 = new TAllocationGenericId();
        alloc2.setIdI(2L);
        alloc2.setDownstreamStatusSW("MATCHED");
        container.addAsFillAndAvg(alloc2);

        // Mock database updates
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Execute
        tmlApsCHFeedUtil.updateMatchedStatus(
            "GROUP123", 
            new MessageStatus("Y", "Matched"), 
            container
        );

        // Verify
        verify(tmlQueryDao).updateWithInClause(contains("STATUS_QUERY"), anyMap());
        verify(tmlQueryDao).updateWithInClause(contains("ORDER_NUM_QRY"), anyMap());
    }

    @Test
    public void testUpdateAllocList() throws Exception {
        // Setup test data using reflection since method is private
        List<TAllocationGenericId> allocs = new ArrayList<>();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setIdI(1L);
        alloc.setDownstreamStatusSW("NOT_MATCHED");
        allocs.add(alloc);

        // Mock update
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Invoke private method via reflection
        Method method = TmlApsCHFeedUtil.class.getDeclaredMethod(
            "updateAllocList", 
            String.class, MessageStatus.class, List.class, String.class
        );
        method.setAccessible(true);
        method.invoke(
            tmlApsCHFeedUtil, 
            "GROUP1", 
            new MessageStatus("Y", "Matched"), 
            allocs, 
            "UPDATE_QUERY"
        );

        // Verify
        verify(tmlQueryDao).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testUpdateAllocGenericList() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setSourceIdI(123L);
        container.addAsFillAndAvg(alloc);

        // Mock update
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);

        // Invoke private method via reflection
        Method method = TmlApsCHFeedUtil.class.getDeclaredMethod(
            "updateAllocGenericList", 
            String.class, AllocContainer.class, String.class
        );
        method.setAccessible(true);
        method.invoke(tmlApsCHFeedUtil, "GROUP1", container, "UPDATE_QUERY");

        // Verify
        verify(tmlQueryDao).updateWithInClause(anyString(), anyMap());
        verify(log).info(contains("Allocation generic table got updated"));
    }

    @Test
    public void testUpdateCHList() throws Exception {
        // Setup
        List<Long> ids = Arrays.asList(1L, 2L, 3L);

        // Mock update
        when(tmlQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(3);

        // Invoke private method via reflection
        Method method = TmlApsCHFeedUtil.class.getDeclaredMethod(
            "updateCHList", 
            String.class, List.class
        );
        method.setAccessible(true);
        method.invoke(tmlApsCHFeedUtil, "GROUP1", ids);

        // Verify
        verify(tmlQueryDao).updateWithInClause(contains("CH_FEED_QRY"), anyMap());
    }
}



@RunWith(MockitoJUnitRunner.class)
public class TmlApsCHFeedUtilTest {

    @InjectMocks
    private TmlApsCHFeedUtil util;

    @Mock
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private ImICollectionUtil imICollectionUtil;

    @Mock
    private SqlRowSet sqlRowSet;

    @Test
    public void testUpdateStatus_withClientProvidedGroupId() throws Exception {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientProvidedApsGrpIdC("123456");

        AllocContainer container = new AllocContainer();
        container.setFills(Collections.singletonList(alloc));
        List<TClearhouseMaster> chMsgs = Collections.singletonList(mock(TClearhouseMaster.class));

        MessageStatus status = new MessageStatus("SUCCESS", "Client provided test");

        boolean result = util.updateStatus(status, chMsgs, container, true);

        assertTrue(result);
    }

    @Test
    public void testUpdateStatus_withoutClientProvidedGroupId() throws Exception {
        TAllocationGenericId alloc = new TAllocationGenericId();

        AllocContainer container = new AllocContainer();
        container.setFills(Collections.singletonList(alloc));
        List<TClearhouseMaster> chMsgs = Collections.singletonList(mock(TClearhouseMaster.class));

        when(tmlQueryDao.getRowSet(anyString())).thenReturn(sqlRowSet);
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getString("GROUP_ID")).thenReturn("99999");

        MessageStatus status = new MessageStatus("SUCCESS", "No client group ID");

        boolean result = util.updateStatus(status, chMsgs, container, false);

        assertTrue(result);
    }

    @Test
    public void testPrivate_updateMatchedStatus_viaReflection() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setIdI(1L);
        alloc.setDownstreamStatusSw("NOT MATCHED");

        AllocContainer container = new AllocContainer();
        container.setFills(Collections.singletonList(alloc));

        MessageStatus status = new MessageStatus("DONE", "Private method test");

        ReflectionTestUtils.invokeMethod(util, "updateMatchedStatus", "GID12", status, container);

        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testPrivate_updateChFeedStatus_viaReflection() {
        TClearhouseMaster chm = mock(TClearhouseMaster.class);
        when(chm.getIdI()).thenReturn(123L);

        AllocContainer container = new AllocContainer();
        List<TClearhouseMaster> chList = Collections.singletonList(chm);

        // Reflectively call updateChFeedStatus
        ReflectionTestUtils.invokeMethod(util, "updateChFeedStatus", "GRP88", chList, container);

        verify(tmlQueryDao, atLeastOnce()).updateWithInClause(anyString(), anyMap());
    }

    @Test
    public void testPrivate_updateAllocGenericList_viaReflection() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setSourceIdI(BigDecimal.valueOf(456L));

        AllocContainer container = new AllocContainer();
        container.setAvg(Collections.singletonList(alloc));

        ReflectionTestUtils.invokeMethod(util, "updateAllocGenericList", "GRP77", container, "UPDATE QRY");

        verify(tmlQueryDao).updateWithInClause(anyString(), anyMap());
    }
}



@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {
    // ... other test methods ...

    @Test
    public void testUpdateMatchedStatus() {
        // Setup
        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(new TAllocationGenericId());
        
        // Solution 1: If you know the method returns int
        when(allocRepository.saveAllocProcesses(anyList())).thenReturn(1);
        
        // Solution 2: If you're not sure
        try {
            doNothing().when(allocRepository).saveAllocProcesses(anyList());
        } catch (org.mockito.exceptions.base.MockitoException e) {
            when(allocRepository.saveAllocProcesses(anyList())).thenReturn(1);
        }
        
        // Execute
        allocationService.updateMatchedStatus("Y", "Message", container);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
    }

    // ... other test methods ...
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Mock
    @Qualifier("gmiSchema")
    private String gmiSchema;

    private Logger log = Logger.getLogger(AllocationServiceImpl.class);

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Initialize broker enrichment map
        ConcurrentHashMap<String, String> brokerEnrichmentMap = new ConcurrentHashMap<>();
        brokerEnrichmentMap.put("EXCH_BROKER_MNEMONIC", "ENRICHED_VALUE");
        setPrivateField(allocationService, "brokerEnrichmentMap", brokerEnrichmentMap);
        
        // Set logger
        setPrivateField(allocationService, "log", log);
        
        when(gmiSchema).thenReturn("TEST_SCHEMA");
    }

    @Test
    public void testUpdateMatchedStatus() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        container.addAsFillAndAvg(alloc);
        
        // Correct mocking for void method
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.updateMatchedStatus("Y", "Test message", container);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
    }

    // Other test methods remain the same...

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Mock
    @Qualifier("gmiSchema")
    private String gmiSchema;

    private Logger log = Logger.getLogger(AllocationServiceImpl.class);

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Initialize broker enrichment map
        ConcurrentHashMap<String, String> brokerEnrichmentMap = new ConcurrentHashMap<>();
        brokerEnrichmentMap.put("EXCH_BROKER_MNEMONIC", "ENRICHED_VALUE");
        setPrivateField(allocationService, "brokerEnrichmentMap", brokerEnrichmentMap);
        
        // Set logger
        setPrivateField(allocationService, "log", log);
        
        when(gmiSchema).thenReturn("TEST_SCHEMA");
    }

    @Test
    public void testApplyEnrichment() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientC("MANAHL");
        alloc.setUnChangedexecBrkMneC("MNEMONIC");
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        
        // Execute
        allocationService.applyEnrichment(container, trnflFills);
        
        // Verify
        assertEquals("ENRICHED_VALUE", alloc.getBrokerEnrichment());
        verify(log).info(anyString());
    }

    @Test
    public void testIsOnlyEnrichment() throws Exception {
        // Test ALLOCATE case
        AllocContainer container1 = new AllocContainer();
        TAllocationGenericId alloc1 = new TAllocationGenericId();
        alloc1.setGmiMatchTypeC("ALLOCATE");
        container1.addAsFillAndAvg(alloc1);
        assertFalse(allocationService.isonlyEnrichment(container1));
        
        // Test UPDATE case
        AllocContainer container2 = new AllocContainer();
        TAllocationGenericId alloc2 = new TAllocationGenericId();
        alloc2.setGmiMatchTypeC("UPDATE");
        container2.addAsFillAndAvg(alloc2);
        assertTrue(allocationService.isonlyEnrichment(container2));
        
        // Test empty case
        assertTrue(allocationService.isonlyEnrichment(new AllocContainer()));
    }

    @Test
    public void testEnrichmentContainer() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientC("MANAHL");
        alloc.setGmiMatchTypeC("UPDATE");
        container.addAsFillAndAvg(alloc);
        
        List<String> ftraceL = Arrays.asList("TRACE1", "TRACE2");
        
        // Mock repository
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.enrichment(container, ftraceL);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
        verify(log, times(2)).info(anyString());
    }

    @Test
    public void testUpdateMatchedStatus() throws Exception {
        // Setup
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = new TAllocationGenericId();
        container.addAsFillAndAvg(alloc);
        
        // Mock repository
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.updateMatchedStatus("Y", "Test message", container);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
    }

    @Test
    public void testFrefnoEnrichment() throws Exception {
        // Setup
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setOrderOrigC("ORIG1234567890"); // 12 chars
        List<String> ftraceL = Arrays.asList("TRACE1");
        Map<String, String> extidMap = new HashMap<>();
        
        // Mock DAO
        when(gmiQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);
        
        // Execute
        allocationService.frefnoEnrichment(alloc, ftraceL, extidMap);
        
        // Verify
        verify(gmiQueryDao).updateWithInClause(anyString(), anyMap());
        verify(log).info(contains("New value: ORIG12345678"));
    }

    @Test
    public void testBrokerEnrichment() throws Exception {
        // Setup
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setUnChangedexecBrkMneC("MNEMONIC");
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER");
        alloc.setGmiMatchTypeC("UPDATE");
        List<String> ftraceL = Arrays.asList("TRACE1");
        
        // Mock DAO
        when(gmiQueryDao.updateWithInClause(anyString(), anyMap())).thenReturn(1);
        
        // Execute
        allocationService.brokerEnrichment(alloc, ftraceL, null);
        
        // Verify
        verify(gmiQueryDao).updateWithInClause(anyString(), anyMap());
        verify(log).info(contains("broker enrichment for"));
    }

    @Test
    public void testSaveTracesInTml() throws Exception {
        // Setup
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setClientC("TEST");
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setId(123L);
        List<String> ftraceL = Arrays.asList("TRACE1");
        
        // Mock repository
        doNothing().when(allocRepository).saveAllocProcesses(anyList());
        
        // Execute
        allocationService.saveTracesInTml(ftraceL, alloc);
        
        // Verify
        verify(allocRepository).saveAllocProcesses(anyList());
        verify(log).info(contains("request to add ftrace"));
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

@Test
public void testFrefnoEnrichmentWithNullOrderOrig() throws Exception {
    TAllocationGenericId alloc = new TAllocationGenericId();
    alloc.setOrderOrigC(null);
    List<String> ftraceL = Arrays.asList("TRACE1");
    
    allocationService.frefnoEnrichment(alloc, ftraceL, null);
    
    verify(log).info(contains("frefno should not be empty"));
    verify(allocRepository).saveAllocProcesses(anyList());
}

@Test
public void testSaveListLargeBatch() throws Exception {
    List<TAllocGmiRef> largeList = new ArrayList<>();
    for (int i = 0; i < 1000; i++) {
        TAllocGmiRef ref = new TAllocGmiRef();
        largeList.add(ref);
    }
    
    // Mock repository
    doNothing().when(allocRepository).saveAllocProcesses(anyList());
    
    allocationService.saveList(largeList);
    
    // Verify it handles large batches by splitting
    verify(allocRepository, atLeast(2)).saveAllocProcesses(anyList());
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessByEachAlloc() {
        // 1. Create test allocation with all required fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        Map<String, AllocContainer> mockMap = new HashMap<>();
        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(alloc);
        mockMap.put("GROUP1", container);
        
        // 2. Mock GMI response
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        fill.setFfc(alloc.getGmiInstTypeC());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(mockTrnflFills);
        
        // 3. Execute via reflection since processAllocs is private
        invokeProcessAllocs(TmlInternalApsJobs.jobs.EACH_FILL, mockMap);
        
        // 4. Verify
        verify(gmiQueryDao).queryForRowMapper(anyString(), any(Map.class), any());
    }

    @Test
    public void testProcessByEachAllocWithNullAccounts() {
        // 1. Create test allocation with null account fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        alloc.setAcctMatchOnC("M"); // Requires matchAcctC
        alloc.setMatchAcctC(null); // Explicitly null
        
        Map<String, AllocContainer> mockMap = new HashMap<>();
        AllocContainer container = new AllocContainer();
        container.addAsFillAndAvg(alloc);
        mockMap.put("GROUP1", container);
        
        // 2. Should handle null accounts gracefully
        invokeProcessAllocs(TmlInternalApsJobs.jobs.EACH_FILL, mockMap);
        
        // 3. Verify warning was logged
        verify(allocationService.log).warn(contains("fills not found"));
    }

    private TAllocationGenericId createCompleteTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        // Required fields
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        
        // Account fields
        alloc.setAcctMatchOnC("C"); // Default to clearing account
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setMatchAcctC("MATCH_ACCT");
        alloc.setExecutionAcctC("EXEC_ACCT");
        
        // Other required fields
        alloc.setTradeDateD(new Date());
        alloc.setGmiExchCdC("TEST_EXCH");
        alloc.setGmiInstTypeC("FUT");
        alloc.setExecBrkMneC("EXEC_BRK");
        alloc.setBs("B");
        alloc.setSilentBrokerC("BROKER1");
        
        return alloc;
    }

    private void invokeProcessAllocs(TmlInternalApsJobs.jobs job, Map<String, AllocContainer> map) {
        try {
            Method method = AllocationServiceImpl.class.getDeclaredMethod(
                "processAllocs", 
                TmlInternalApsJobs.jobs.class, Map.class);
            method.setAccessible(true);
            method.invoke(allocationService, job, map);
        } catch (Exception e) {
            throw new RuntimeException("Failed to invoke processAllocs", e);
        }
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessByEachAlloc() {
        // 1. Create test allocation with ALL required fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO response
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI response
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processByEachAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    private TAllocationGenericId createCompleteTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        // Required fields
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        
        // Account fields required for getGmiLookUpAc
        alloc.setAcctMatchOnC("C"); // or "M"/"E" depending on your needs
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setMatchAcctC("MATCH_ACCT"); // If using match account
        alloc.setExecutionAcctC("EXEC_ACCT"); // If using exec account
        
        // Other required fields
        alloc.setTradeDateD(new Date());
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER1");
        
        return alloc;
    }

    @Test
    public void testGetGmiLookUpAc() {
        // Test all account matching scenarios
        List<TAllocationGenericId> fills = new ArrayList<>();
        
        // Clearing account case
        TAllocationGenericId alloc1 = createCompleteTestAllocation();
        alloc1.setAcctMatchOnC("C");
        alloc1.setClearingAcctC("CLEARING_ACCT");
        fills.add(alloc1);
        
        // Match account case
        TAllocationGenericId alloc2 = createCompleteTestAllocation();
        alloc2.setAcctMatchOnC("M");
        alloc2.setMatchAcctC("MATCH_ACCT");
        fills.add(alloc2);
        
        // Execution account case
        TAllocationGenericId alloc3 = createCompleteTestAllocation();
        alloc3.setAcctMatchOnC("E");
        alloc3.setExecutionAcctC("EXEC_ACCT");
        fills.add(alloc3);
        
        // Default case
        TAllocationGenericId alloc4 = createCompleteTestAllocation();
        alloc4.setAcctMatchOnC(null);
        alloc4.setClearingAcctC("DEFAULT_ACCT");
        fills.add(alloc4);
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(4, result.size());
        assertTrue(result.contains("CLEARING_ACCT"));
        assertTrue(result.contains("MATCH_ACCT"));
        assertTrue(result.contains("EXEC_ACCT"));
        assertTrue(result.contains("DEFAULT_ACCT"));
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

@Test
public void testProcessByEachAlloc() {
    // Given
    TAllocationGenericId testAlloc = createTestAllocation("GROUP1", "100.50");
    List<TAllocationGenericId> mockAllocations = Collections.singletonList(testAlloc);

    AllocContainer mockContainer = mock(AllocContainer.class);
    when(mockContainer.getFills()).thenReturn(mockAllocations);

    Map<String, AllocContainer> allocMap = new HashMap<>();
    allocMap.put("GROUP1", mockContainer);

    // Stub DAO call
    when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class))
    ).thenReturn(mockAllocations);

    // Stub getGmiLookUpAC if needed
    when(allocationService.getGmiLookUpAC(anyList())).thenReturn(mock(LookUpAC.class));

    // Optionally stub methods like checkForEachFillExistInGMI if they're not real
    doReturn(true).when(allocationService).checkForEachFillExistInGMI(
            anyList(), anyList(), anyList(), any()
    );

    // Inject the mocked map into the private method using reflection (if needed)
    ReflectionTestUtils.invokeMethod(
        allocationService,
        "processAllocs",
        TmlInternalApsJobs.jobs.BACH_FILL,
        allocMap
    );

    // Then
    verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class)
    );
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final SimpleDateFormat tradeDtFormat = new SimpleDateFormat("yyyyMMdd");
    private static final SimpleDateFormat matDtFormat = new SimpleDateFormat("yyyyMMdd");
    private static final SimpleDateFormat matDayFormat = new SimpleDateFormat("dd");

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Initialize formats
        setPrivateField(allocationService, "tradeDtFormat", tradeDtFormat);
        setPrivateField(allocationService, "matDtFormat", matDtFormat);
        setPrivateField(allocationService, "matDayFormat", matDayFormat);
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC("TEST_EXCH"); // Set exchange code
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        fill.setFfc(alloc.getGmiInstTypeC());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Mock GMI query response
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(trnflFills);
        
        // 5. Invoke via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 6. Verify
        assertTrue("Fills should match allocations", result);
    }

    @Test
    public void testCheckIfFillsSumMatchesWithNullExchange() throws Exception {
        // 1. Create test data with null exchange code
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC(null); // Null exchange code
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Should handle null exchange code gracefully
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 3. Invoke via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 4. Verify
        assertFalse("Should return false with null exchange code", result);
    }

    @Test
    public void testProcessBySumAllocWithExchangeCheck() {
        // 1. Create test data with exchange code
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC("TEST_EXCH");
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI response with matching exchange code
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setMaturityDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        alloc.setGmiExchCdC("TEST_EXCH");
        alloc.setGmiInstTypeC("FUT");
        alloc.setExecBrkMneC("EXEC_BRK");
        alloc.setBs("B");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessBySumAlloc() {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI check to return matching fills
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
        
        verify(gmiQueryDao, atLeastOnce()).queryForRowMapper(
            anyString(), any(Object[].class), any());
    }

    @Test
    public void testProcessBySumAllocWithNullFills() {
        // 1. Create valid test allocation
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO to return our test allocation
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI to return empty list (no matching fills)
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(Collections.emptyList());
        
        // 4. Execute - should handle null fills gracefully
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Invoke directly via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 5. Verify
        assertTrue("Fills should match allocations", result);
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessBySumAlloc() {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI check to return matching fills
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
        
        verify(gmiQueryDao, atLeastOnce()).queryForRowMapper(
            anyString(), any(Object[].class), any());
    }

    @Test
    public void testProcessBySumAllocWithNullFills() {
        // 1. Create valid test allocation
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO to return our test allocation
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI to return empty list (no matching fills)
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(Collections.emptyList());
        
        // 4. Execute - should handle null fills gracefully
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Invoke directly via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 5. Verify
        assertTrue("Fills should match allocations", result);
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0)) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessBySumAlloc() {
        // Create test allocation with all required fields
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.50");
        alloc.setAcctMatchOnC("C"); // Set account matching type
        alloc.setClearingAcctC("CLEARING_ACCT"); // Set required account field
        
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // Mock GMI check to return some dummy data
        List<Gmitrnfl> dummyTrnflFills = new ArrayList<>();
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(dummyTrnflFills);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocWithNullAccounts() {
        // Create test allocation with null account fields
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.50");
        alloc.setAcctMatchOnC("M"); // Matching type that requires matchAcctC
        // Intentionally not setting matchAcctC to test null handling
        
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // Should handle null accounts gracefully
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testGetGmiLookUpAcWithDifferentAccountTypes() {
        List<TAllocationGenericId> fills = new ArrayList<>();
        
        // Clearing account
        TAllocationGenericId alloc1 = createTestAllocation("GROUP1", "100.00");
        alloc1.setAcctMatchOnC("C");
        alloc1.setClearingAcctC("CLEARING_ACCT");
        fills.add(alloc1);
        
        // Match account
        TAllocationGenericId alloc2 = createTestAllocation("GROUP2", "200.00");
        alloc2.setAcctMatchOnC("M");
        alloc2.setMatchAcctC("MATCH_ACCT");
        fills.add(alloc2);
        
        // Execution account
        TAllocationGenericId alloc3 = createTestAllocation("GROUP3", "300.00");
        alloc3.setAcctMatchOnC("E");
        alloc3.setExecutionAcctC("EXEC_ACCT");
        fills.add(alloc3);
        
        // Default case
        TAllocationGenericId alloc4 = createTestAllocation("GROUP4", "400.00");
        alloc4.setAcctMatchOnC(null);
        alloc4.setClearingAcctC("DEFAULT_ACCT");
        fills.add(alloc4);
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(4, result.size());
        assertTrue(result.contains("CLEARING_ACCT"));
        assertTrue(result.contains("MATCH_ACCT"));
        assertTrue(result.contains("EXEC_ACCT"));
        assertTrue(result.contains("DEFAULT_ACCT"));
    }

    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }
}






import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // EXACT SQL query from your production code
    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0)) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByEachAlloc() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        // EXACT mock setup matching production call
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processByEachAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processBySumAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class));
    }

    // Helper method to create test allocations
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    @Test
    public void testEmptyAllocations() {
        // Given
        when(tmlQueryDao.queryForRowMapper(
            anyString(), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(Collections.emptyList());
        
        // When
        allocationService.processByEachAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test(expected = RuntimeException.class)
    public void testDaoExceptionHandling() {
        // Given
        when(tmlQueryDao.queryForRowMapper(
            anyString(), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenThrow(new RuntimeException("Database error"));
        
        // When
        allocationService.processByEachAlloc();
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.RowMapper;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // Actual SQL query from production code
    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS " +
        "WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " +
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RIS', 'NMY') " +
        "ORDER BY id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByEachAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        // Mock with the exact SQL query and proper mapper
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByEachAlloc();
        
        // Verify the exact SQL was used with proper mapper
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(),
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(),
            any(TAllocationProcessMapper.class));
    }

    // Helper method to create test allocations
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.RowMapper;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // Constants that should match your production code
    private static final String EACH_ALLOC_SQL = "SELECT * FROM allocations";
    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";
    private static final String UPDATE_ALLOCATION_STATUS_QUERY = "UPDATE allocations SET status = ?";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    // Use real String instead of mock
    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        
        // Initialize broker enrichment map
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
        
        // Initialize the service
        allocationService.init();
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByBachAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(eq(EACH_ALLOC_SQL), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByBachAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(eq(EACH_ALLOC_SQL), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(eq(SUM_BY_ALLOC_SQL), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(eq(SUM_BY_ALLOC_SQL), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(RowMapper.class));
    }

    @Test
    public void testGetGmiLookUpAc() {
        List<TAllocationGenericId> fills = Arrays.asList(
            createTestAllocationWithAccount("C", "ACCT1", null, null),
            createTestAllocationWithAccount("M", null, "ACCT2", null),
            createTestAllocationWithAccount("E", null, null, "ACCT3")
        );
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(3, result.size());
        assertTrue(result.contains("ACCT1"));
        assertTrue(result.contains("ACCT2"));
        assertTrue(result.contains("ACCT3"));
    }

    @Test
    public void testCalcAvgPxIfNoPxMatch() throws Exception {
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.00");
        alloc.setIsGmiPriceMatch("N");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = Arrays.asList(
            createGmiTrnFl(100, "110.00"),
            createGmiTrnFl(100, "90.00")
        );
        
        allocationService.calcAvgPxIfNoPxMatch(container, trnflFills);
        
        assertEquals(new BigDecimal("100.00"), container.getAvg().get(0).getPriceD());
    }

    // Helper methods
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private TAllocationGenericId createTestAllocationWithAccount(
            String matchType, String clearingAcct, String matchAcct, String execAcct) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setAcctMatchOnC(matchType);
        alloc.setClearingAcctC(clearingAcct);
        alloc.setMatchAcctC(matchAcct);
        alloc.setExecutionAcctC(execAcct);
        return alloc;
    }

    private Gmitrnfl createGmiTrnFl(int qty, String price) {
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(qty);
        fill.setFtpric(new BigDecimal(price));
        return fill;
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    // Use real String instead of mock
    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        
        // Initialize broker enrichment map
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
        
        // Initialize the service
        allocationService.init();
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByBatchAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(anyString(), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByBatchAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(anyString(), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(anyString(), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(anyString(), isNull(), any(RowMapper.class));
    }

    @Test
    public void testGetGmiLookUpAc() {
        List<TAllocationGenericId> fills = Arrays.asList(
            createTestAllocationWithAccount("C", "ACCT1", null, null),
            createTestAllocationWithAccount("M", null, "ACCT2", null),
            createTestAllocationWithAccount("E", null, null, "ACCT3")
        );
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(3, result.size());
        assertTrue(result.contains("ACCT1"));
        assertTrue(result.contains("ACCT2"));
        assertTrue(result.contains("ACCT3"));
    }

    @Test
    public void testCalcAvgPxIfNoPxMatch() throws Exception {
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.00");
        alloc.setIsGmiPriceMatch("N");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = Arrays.asList(
            createGmiTrnFl(100, "110.00"),
            createGmiTrnFl(100, "90.00")
        );
        
        allocationService.calcAvgPxIfNoPxMatch(container, trnflFills);
        
        assertEquals(new BigDecimal("100.00"), container.getAvg().get(0).getPriceD());
    }

    // Helper methods
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private TAllocationGenericId createTestAllocationWithAccount(
            String matchType, String clearingAcct, String matchAcct, String execAcct) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setAcctMatchOnC(matchType);
        alloc.setClearingAcctC(clearingAcct);
        alloc.setMatchAcctC(matchAcct);
        alloc.setExecutionAcctC(execAcct);
        return alloc;
    }

    private Gmitrnfl createGmiTrnFl(int qty, String price) {
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(qty);
        fill.setFtpric(new BigDecimal(price));
        return fill;
    }

    // Add other test methods as needed...
}


@Test
public void testProcessBySumAllocByBroker() {
    // Setup test data
    List<TAllocationGenericId> mockAllocations = new ArrayList<>();
    TAllocationGenericId alloc = new TAllocationGenericId();
    alloc.setTmlAllocGroupIdC("GROUP1");
    alloc.setPriceD(new BigDecimal("100.50"));
    alloc.setSilentBrokerC("BROKER1");
    mockAllocations.add(alloc);

    // Mock the queryForRowMapper call with proper argument types
    when(tmlQueryDao.queryForRowMapper(
        eq(BROKER_SUM_BY_ALLOC_SQL),  // or anyString() if you prefer
        isNull(Object[].class),
        any(RowMapper.class)))  // Changed from TAllocationProcessMapper.class
        .thenReturn(mockAllocations);

    // Execute
    allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);

    // Verify
    verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(
        eq(BROKER_SUM_BY_ALLOC_SQL),  // or anyString()
        isNull(Object[].class),
        any(RowMapper.class));
    verify(log, atLeastOnce()).info(anyString());
}


import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.*;
import java.math.BigDecimal;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.StringUtil;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() {
        allocationService = new AllocationServiceImpl();
        MockitoAnnotations.initMocks(this);

        allocationService.tmlQueryDao = tmlQueryDao;
        allocationService.gmiQueryDao = gmiQueryDao;
        allocationService.allocRepository = allocRepository;
        allocationService.gmiSchema = "TEST_SCHEMA";
    }

    @Test
    public void testProcessByBatchAlloc() throws Exception {
        List<TAllocationGenericId> dummyList = Collections.singletonList(mock(TAllocationGenericId.class));
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(dummyList);

        allocationService.processByBachAlloc();

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testProcessBySumAlloc() throws Exception {
        List<TAllocationGenericId> dummyList = Collections.singletonList(mock(TAllocationGenericId.class));
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(dummyList);

        allocationService.processBySumAlloc();

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testProcessBySumAllocByBroker_withEmptyAllocations() throws Exception {
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(Collections.emptyList());

        allocationService.processBySumAllocByBroker(ImlAllocationJobs.jobs.SUM_FILL_BROKER);

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testGetGmiLookUpAc() {
        TAllocationGenericId allocation = mock(TAllocationGenericId.class);
        when(allocation.getAcctMatchOnC()).thenReturn("M");
        when(allocation.getMatchAcctC()).thenReturn("MATCH123");

        List<TAllocationGenericId> allocations = Arrays.asList(allocation);
        List<String> result = allocationService.getGmiLookUpAc(allocations);

        assertEquals(1, result.size());
        assertTrue(result.contains("MATCH123"));
    }

    @Test
    public void testAddFtype_WhenCMEGroup() {
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getGmiExchCdC()).thenReturn("CME");

        String result = allocationService.addFtype(alloc, "first", "withFtype");
        assertNotNull(result);
    }

    @Test
    public void testAddFtpric_WhenPriceNotMatched() {
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getClientC()).thenReturn("MOORECAP");
        when(alloc.getIsGmiPriceMatch()).thenReturn("N");

        allocationService.currentJob = ImlAllocationJobs.jobs.SUM_FILL_BROKER_NO_PRICE;

        String result = allocationService.addFtpric(alloc, "withFtpric");
        assertNotNull(result);
    }
}
