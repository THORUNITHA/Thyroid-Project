  
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessByEachAlloc() {
        // 1. Create test allocation with ALL required fields
        TAllocationGenericId alloc = createCompleteTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO response
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI response
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processByEachAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    private TAllocationGenericId createCompleteTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        // Required fields
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        
        // Account fields required for getGmiLookUpAc
        alloc.setAcctMatchOnC("C"); // or "M"/"E" depending on your needs
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setMatchAcctC("MATCH_ACCT"); // If using match account
        alloc.setExecutionAcctC("EXEC_ACCT"); // If using exec account
        
        // Other required fields
        alloc.setTradeDateD(new Date());
        alloc.setGmiExchCdC("EXCH");
        alloc.setSilentBrokerC("BROKER1");
        
        return alloc;
    }

    @Test
    public void testGetGmiLookUpAc() {
        // Test all account matching scenarios
        List<TAllocationGenericId> fills = new ArrayList<>();
        
        // Clearing account case
        TAllocationGenericId alloc1 = createCompleteTestAllocation();
        alloc1.setAcctMatchOnC("C");
        alloc1.setClearingAcctC("CLEARING_ACCT");
        fills.add(alloc1);
        
        // Match account case
        TAllocationGenericId alloc2 = createCompleteTestAllocation();
        alloc2.setAcctMatchOnC("M");
        alloc2.setMatchAcctC("MATCH_ACCT");
        fills.add(alloc2);
        
        // Execution account case
        TAllocationGenericId alloc3 = createCompleteTestAllocation();
        alloc3.setAcctMatchOnC("E");
        alloc3.setExecutionAcctC("EXEC_ACCT");
        fills.add(alloc3);
        
        // Default case
        TAllocationGenericId alloc4 = createCompleteTestAllocation();
        alloc4.setAcctMatchOnC(null);
        alloc4.setClearingAcctC("DEFAULT_ACCT");
        fills.add(alloc4);
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(4, result.size());
        assertTrue(result.contains("CLEARING_ACCT"));
        assertTrue(result.contains("MATCH_ACCT"));
        assertTrue(result.contains("EXEC_ACCT"));
        assertTrue(result.contains("DEFAULT_ACCT"));
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

@Test
public void testProcessByEachAlloc() {
    // Given
    TAllocationGenericId testAlloc = createTestAllocation("GROUP1", "100.50");
    List<TAllocationGenericId> mockAllocations = Collections.singletonList(testAlloc);

    AllocContainer mockContainer = mock(AllocContainer.class);
    when(mockContainer.getFills()).thenReturn(mockAllocations);

    Map<String, AllocContainer> allocMap = new HashMap<>();
    allocMap.put("GROUP1", mockContainer);

    // Stub DAO call
    when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class))
    ).thenReturn(mockAllocations);

    // Stub getGmiLookUpAC if needed
    when(allocationService.getGmiLookUpAC(anyList())).thenReturn(mock(LookUpAC.class));

    // Optionally stub methods like checkForEachFillExistInGMI if they're not real
    doReturn(true).when(allocationService).checkForEachFillExistInGMI(
            anyList(), anyList(), anyList(), any()
    );

    // Inject the mocked map into the private method using reflection (if needed)
    ReflectionTestUtils.invokeMethod(
        allocationService,
        "processAllocs",
        TmlInternalApsJobs.jobs.BACH_FILL,
        allocMap
    );

    // Then
    verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class)
    );
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final SimpleDateFormat tradeDtFormat = new SimpleDateFormat("yyyyMMdd");
    private static final SimpleDateFormat matDtFormat = new SimpleDateFormat("yyyyMMdd");
    private static final SimpleDateFormat matDayFormat = new SimpleDateFormat("dd");

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Initialize formats
        setPrivateField(allocationService, "tradeDtFormat", tradeDtFormat);
        setPrivateField(allocationService, "matDtFormat", matDtFormat);
        setPrivateField(allocationService, "matDayFormat", matDayFormat);
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC("TEST_EXCH"); // Set exchange code
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        fill.setFfc(alloc.getGmiInstTypeC());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Mock GMI query response
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(trnflFills);
        
        // 5. Invoke via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 6. Verify
        assertTrue("Fills should match allocations", result);
    }

    @Test
    public void testCheckIfFillsSumMatchesWithNullExchange() throws Exception {
        // 1. Create test data with null exchange code
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC(null); // Null exchange code
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Should handle null exchange code gracefully
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 3. Invoke via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 4. Verify
        assertFalse("Should return false with null exchange code", result);
    }

    @Test
    public void testProcessBySumAllocWithExchangeCheck() {
        // 1. Create test data with exchange code
        TAllocationGenericId alloc = createValidTestAllocation();
        alloc.setGmiExchCdC("TEST_EXCH");
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI response with matching exchange code
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        fill.setFexch(alloc.getGmiExchCdC());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Map.class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setMaturityDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        alloc.setGmiExchCdC("TEST_EXCH");
        alloc.setGmiInstTypeC("FUT");
        alloc.setExecBrkMneC("EXEC_BRK");
        alloc.setBs("B");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessBySumAlloc() {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI check to return matching fills
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
        
        verify(gmiQueryDao, atLeastOnce()).queryForRowMapper(
            anyString(), any(Object[].class), any());
    }

    @Test
    public void testProcessBySumAllocWithNullFills() {
        // 1. Create valid test allocation
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO to return our test allocation
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI to return empty list (no matching fills)
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(Collections.emptyList());
        
        // 4. Execute - should handle null fills gracefully
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Invoke directly via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 5. Verify
        assertTrue("Fills should match allocations", result);
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", "test_schema");
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    @Test
    public void testProcessBySumAlloc() {
        // 1. Create test data with all required fields
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO responses
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI check to return matching fills
        List<Gmitrnfl> mockTrnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        mockTrnflFills.add(fill);
        
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(mockTrnflFills);
        
        // 4. Execute
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
        
        verify(gmiQueryDao, atLeastOnce()).queryForRowMapper(
            anyString(), any(Object[].class), any());
    }

    @Test
    public void testProcessBySumAllocWithNullFills() {
        // 1. Create valid test allocation
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        // 2. Mock DAO to return our test allocation
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // 3. Mock GMI to return empty list (no matching fills)
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(Collections.emptyList());
        
        // 4. Execute - should handle null fills gracefully
        allocationService.processBySumAlloc();
        
        // 5. Verify
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testCheckIfFillsSumMatches() throws Exception {
        // 1. Create test data
        TAllocationGenericId alloc = createValidTestAllocation();
        List<TAllocationGenericId> allocations = Collections.singletonList(alloc);
        
        // 2. Create matching GMI fills
        List<Gmitrnfl> trnflFills = new ArrayList<>();
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(alloc.getQuantityI());
        fill.setFtpric(alloc.getPriceD());
        trnflFills.add(fill);
        
        List<Gmiidsf1> idsf1Fills = new ArrayList<>();
        
        // 3. Get account list
        List<String> accounts = allocationService.getGmiLookUpAc(allocations);
        
        // 4. Invoke directly via reflection
        Method method = AllocationServiceImpl.class.getDeclaredMethod(
            "checkIfFillsSumMatches", 
            List.class, List.class, List.class, List.class);
        method.setAccessible(true);
        
        boolean result = (boolean) method.invoke(
            allocationService, 
            allocations, trnflFills, idsf1Fills, accounts);
        
        // 5. Verify
        assertTrue("Fills should match allocations", result);
    }

    private TAllocationGenericId createValidTestAllocation() {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC("GROUP1");
        alloc.setPriceD(new BigDecimal("100.50"));
        alloc.setQuantityI(100);
        alloc.setAcctMatchOnC("C");
        alloc.setClearingAcctC("CLEARING_ACCT");
        alloc.setTradeDateD(new Date());
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0)) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessBySumAlloc() {
        // Create test allocation with all required fields
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.50");
        alloc.setAcctMatchOnC("C"); // Set account matching type
        alloc.setClearingAcctC("CLEARING_ACCT"); // Set required account field
        
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // Mock GMI check to return some dummy data
        List<Gmitrnfl> dummyTrnflFills = new ArrayList<>();
        when(gmiQueryDao.queryForRowMapper(anyString(), any(Object[].class), any()))
            .thenReturn(dummyTrnflFills);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocWithNullAccounts() {
        // Create test allocation with null account fields
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.50");
        alloc.setAcctMatchOnC("M"); // Matching type that requires matchAcctC
        // Intentionally not setting matchAcctC to test null handling
        
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(alloc);
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // Should handle null accounts gracefully
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testGetGmiLookUpAcWithDifferentAccountTypes() {
        List<TAllocationGenericId> fills = new ArrayList<>();
        
        // Clearing account
        TAllocationGenericId alloc1 = createTestAllocation("GROUP1", "100.00");
        alloc1.setAcctMatchOnC("C");
        alloc1.setClearingAcctC("CLEARING_ACCT");
        fills.add(alloc1);
        
        // Match account
        TAllocationGenericId alloc2 = createTestAllocation("GROUP2", "200.00");
        alloc2.setAcctMatchOnC("M");
        alloc2.setMatchAcctC("MATCH_ACCT");
        fills.add(alloc2);
        
        // Execution account
        TAllocationGenericId alloc3 = createTestAllocation("GROUP3", "300.00");
        alloc3.setAcctMatchOnC("E");
        alloc3.setExecutionAcctC("EXEC_ACCT");
        fills.add(alloc3);
        
        // Default case
        TAllocationGenericId alloc4 = createTestAllocation("GROUP4", "400.00");
        alloc4.setAcctMatchOnC(null);
        alloc4.setClearingAcctC("DEFAULT_ACCT");
        fills.add(alloc4);
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(4, result.size());
        assertTrue(result.contains("CLEARING_ACCT"));
        assertTrue(result.contains("MATCH_ACCT"));
        assertTrue(result.contains("EXEC_ACCT"));
        assertTrue(result.contains("DEFAULT_ACCT"));
    }

    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }
}






import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // EXACT SQL query from your production code
    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " + 
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0)) " +
        "AND DOWNSTREAM_STATUS_SW in ('RTS', 'NMY') " +
        "order by id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByEachAlloc() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        // EXACT mock setup matching production call
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processByEachAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processBySumAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        // Given
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        // When
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(TAllocationProcessMapper.class));
    }

    // Helper method to create test allocations
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    @Test
    public void testEmptyAllocations() {
        // Given
        when(tmlQueryDao.queryForRowMapper(
            anyString(), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(Collections.emptyList());
        
        // When
        allocationService.processByEachAlloc();
        
        // Then
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class));
    }

    @Test(expected = RuntimeException.class)
    public void testDaoExceptionHandling() {
        // Given
        when(tmlQueryDao.queryForRowMapper(
            anyString(), 
            isNull(Object[].class), 
            any(TAllocationProcessMapper.class)))
            .thenThrow(new RuntimeException("Database error"));
        
        // When
        allocationService.processByEachAlloc();
    }
}

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.persistence.dao.util.TAllocationProcessMapper;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.RowMapper;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // Actual SQL query from production code
    private static final String EACH_ALLOC_SQL = 
        "SELECT * FROM T_GMI_ALLOC_PROCESS " +
        "WHERE 1=1 " +
        "AND (TRADE_DATE_DT = trunc(SYSDATE-0) " +
        "OR (TRADE_DATE_DT < trunc(SYSDATE-0) " +
        "AND trunc(LAST_UPDATE_TS) = trunc(sysdate-0))) " +
        "AND DOWNSTREAM_STATUS_SW in ('RIS', 'NMY') " +
        "ORDER BY id_i";

    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByEachAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        // Mock with the exact SQL query and proper mapper
        when(tmlQueryDao.queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByEachAlloc();
        
        // Verify the exact SQL was used with proper mapper
        verify(tmlQueryDao).queryForRowMapper(
            eq(EACH_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(SUM_BY_ALLOC_SQL), 
            isNull(), 
            any(TAllocationProcessMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(),
            any(TAllocationProcessMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(),
            any(TAllocationProcessMapper.class));
    }

    // Helper method to create test allocations
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.RowMapper;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    // Constants that should match your production code
    private static final String EACH_ALLOC_SQL = "SELECT * FROM allocations";
    private static final String SUM_BY_ALLOC_SQL = "SELECT * FROM allocations_sum";
    private static final String BROKER_SUM_BY_ALLOC_SQL = "SELECT * FROM broker_allocations_sum";
    private static final String UPDATE_ALLOCATION_STATUS_QUERY = "UPDATE allocations SET status = ?";

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    // Use real String instead of mock
    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        
        // Initialize broker enrichment map
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
        
        // Initialize the service
        allocationService.init();
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByBachAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(eq(EACH_ALLOC_SQL), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByBachAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(eq(EACH_ALLOC_SQL), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(eq(SUM_BY_ALLOC_SQL), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(eq(SUM_BY_ALLOC_SQL), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL), 
            isNull(Object[].class), 
            any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(
            eq(BROKER_SUM_BY_ALLOC_SQL),
            isNull(Object[].class),
            any(RowMapper.class));
    }

    @Test
    public void testGetGmiLookUpAc() {
        List<TAllocationGenericId> fills = Arrays.asList(
            createTestAllocationWithAccount("C", "ACCT1", null, null),
            createTestAllocationWithAccount("M", null, "ACCT2", null),
            createTestAllocationWithAccount("E", null, null, "ACCT3")
        );
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(3, result.size());
        assertTrue(result.contains("ACCT1"));
        assertTrue(result.contains("ACCT2"));
        assertTrue(result.contains("ACCT3"));
    }

    @Test
    public void testCalcAvgPxIfNoPxMatch() throws Exception {
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.00");
        alloc.setIsGmiPriceMatch("N");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = Arrays.asList(
            createGmiTrnFl(100, "110.00"),
            createGmiTrnFl(100, "90.00")
        );
        
        allocationService.calcAvgPxIfNoPxMatch(container, trnflFills);
        
        assertEquals(new BigDecimal("100.00"), container.getAvg().get(0).getPriceD());
    }

    // Helper methods
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private TAllocationGenericId createTestAllocationWithAccount(
            String matchType, String clearingAcct, String matchAcct, String execAcct) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setAcctMatchOnC(matchType);
        alloc.setClearingAcctC(clearingAcct);
        alloc.setMatchAcctC(matchAcct);
        alloc.setExecutionAcctC(execAcct);
        return alloc;
    }

    private Gmitrnfl createGmiTrnFl(int qty, String price) {
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(qty);
        fill.setFtpric(new BigDecimal(price));
        return fill;
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.lang.reflect.Field;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.beans.factory.annotation.Qualifier;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    @Qualifier("tmlQueryDao")
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    @Qualifier("gmiQueryDao")
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    // Use real String instead of mock
    private String gmiSchema = "test_schema";

    @Before
    public void setUp() throws Exception {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);
        
        // Set private fields using reflection
        setPrivateField(allocationService, "gmiSchema", gmiSchema);
        setPrivateField(allocationService, "log", mock(Logger.class));
        
        // Initialize broker enrichment map
        setPrivateField(allocationService, "brokerEnrichmentMap", new ConcurrentHashMap<>());
        
        // Mock DAO responses
        Map<String, PriceScaling> priceMap = new HashMap<>();
        when(tmlQueryDao.getSpecificPriceMap(anyString())).thenReturn(priceMap);
        
        // Initialize the service
        allocationService.init();
    }

    private void setPrivateField(Object target, String fieldName, Object value) 
            throws NoSuchFieldException, IllegalAccessException {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testProcessByBatchAlloc() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(anyString(), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processByBatchAlloc();
        
        verify(tmlQueryDao).queryForRowMapper(anyString(), isNull(), any(RowMapper.class));
    }

    @Test
    public void testProcessBySumAllocByBroker() {
        List<TAllocationGenericId> mockAllocations = Collections.singletonList(
            createTestAllocation("GROUP1", "100.50"));
        
        when(tmlQueryDao.queryForRowMapper(anyString(), isNull(), any(RowMapper.class)))
            .thenReturn(mockAllocations);
        
        allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);
        
        verify(tmlQueryDao).queryForRowMapper(anyString(), isNull(), any(RowMapper.class));
    }

    @Test
    public void testGetGmiLookUpAc() {
        List<TAllocationGenericId> fills = Arrays.asList(
            createTestAllocationWithAccount("C", "ACCT1", null, null),
            createTestAllocationWithAccount("M", null, "ACCT2", null),
            createTestAllocationWithAccount("E", null, null, "ACCT3")
        );
        
        List<String> result = allocationService.getGmiLookUpAc(fills);
        
        assertEquals(3, result.size());
        assertTrue(result.contains("ACCT1"));
        assertTrue(result.contains("ACCT2"));
        assertTrue(result.contains("ACCT3"));
    }

    @Test
    public void testCalcAvgPxIfNoPxMatch() throws Exception {
        AllocContainer container = new AllocContainer();
        TAllocationGenericId alloc = createTestAllocation("GROUP1", "100.00");
        alloc.setIsGmiPriceMatch("N");
        container.addAsFillAndAvg(alloc);
        
        List<Gmitrnfl> trnflFills = Arrays.asList(
            createGmiTrnFl(100, "110.00"),
            createGmiTrnFl(100, "90.00")
        );
        
        allocationService.calcAvgPxIfNoPxMatch(container, trnflFills);
        
        assertEquals(new BigDecimal("100.00"), container.getAvg().get(0).getPriceD());
    }

    // Helper methods
    private TAllocationGenericId createTestAllocation(String groupId, String price) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setTmlAllocGroupIdC(groupId);
        alloc.setPriceD(new BigDecimal(price));
        alloc.setSilentBrokerC("BROKER1");
        return alloc;
    }

    private TAllocationGenericId createTestAllocationWithAccount(
            String matchType, String clearingAcct, String matchAcct, String execAcct) {
        TAllocationGenericId alloc = new TAllocationGenericId();
        alloc.setAcctMatchOnC(matchType);
        alloc.setClearingAcctC(clearingAcct);
        alloc.setMatchAcctC(matchAcct);
        alloc.setExecutionAcctC(execAcct);
        return alloc;
    }

    private Gmitrnfl createGmiTrnFl(int qty, String price) {
        Gmitrnfl fill = new Gmitrnfl();
        fill.setFqty(qty);
        fill.setFtpric(new BigDecimal(price));
        return fill;
    }

    // Add other test methods as needed...
}


@Test
public void testProcessBySumAllocByBroker() {
    // Setup test data
    List<TAllocationGenericId> mockAllocations = new ArrayList<>();
    TAllocationGenericId alloc = new TAllocationGenericId();
    alloc.setTmlAllocGroupIdC("GROUP1");
    alloc.setPriceD(new BigDecimal("100.50"));
    alloc.setSilentBrokerC("BROKER1");
    mockAllocations.add(alloc);

    // Mock the queryForRowMapper call with proper argument types
    when(tmlQueryDao.queryForRowMapper(
        eq(BROKER_SUM_BY_ALLOC_SQL),  // or anyString() if you prefer
        isNull(Object[].class),
        any(RowMapper.class)))  // Changed from TAllocationProcessMapper.class
        .thenReturn(mockAllocations);

    // Execute
    allocationService.processBySumAllocByBroker(TmlAllocationJobs.jobs.SUM_FILL_BROKER);

    // Verify
    verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(
        eq(BROKER_SUM_BY_ALLOC_SQL),  // or anyString()
        isNull(Object[].class),
        any(RowMapper.class));
    verify(log, atLeastOnce()).info(anyString());
}


import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.*;
import java.math.BigDecimal;

import com.baml.tml.tmlbase.trade.persistence.dao.util.QueryDaoJdbc;
import com.baml.tml.tmlbase.trade.util.StringUtil;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class AllocationServiceImplTest {

    @InjectMocks
    private AllocationServiceImpl allocationService;

    @Mock
    private QueryDaoJdbc tmlQueryDao;

    @Mock
    private QueryDaoJdbc gmiQueryDao;

    @Mock
    private AllocRepository allocRepository;

    @Before
    public void setUp() {
        allocationService = new AllocationServiceImpl();
        MockitoAnnotations.initMocks(this);

        allocationService.tmlQueryDao = tmlQueryDao;
        allocationService.gmiQueryDao = gmiQueryDao;
        allocationService.allocRepository = allocRepository;
        allocationService.gmiSchema = "TEST_SCHEMA";
    }

    @Test
    public void testProcessByBatchAlloc() throws Exception {
        List<TAllocationGenericId> dummyList = Collections.singletonList(mock(TAllocationGenericId.class));
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(dummyList);

        allocationService.processByBachAlloc();

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testProcessBySumAlloc() throws Exception {
        List<TAllocationGenericId> dummyList = Collections.singletonList(mock(TAllocationGenericId.class));
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(dummyList);

        allocationService.processBySumAlloc();

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testProcessBySumAllocByBroker_withEmptyAllocations() throws Exception {
        when(tmlQueryDao.queryForRowMapper(anyString(), any(), any())).thenReturn(Collections.emptyList());

        allocationService.processBySumAllocByBroker(ImlAllocationJobs.jobs.SUM_FILL_BROKER);

        verify(tmlQueryDao, atLeastOnce()).queryForRowMapper(anyString(), any(), any());
    }

    @Test
    public void testGetGmiLookUpAc() {
        TAllocationGenericId allocation = mock(TAllocationGenericId.class);
        when(allocation.getAcctMatchOnC()).thenReturn("M");
        when(allocation.getMatchAcctC()).thenReturn("MATCH123");

        List<TAllocationGenericId> allocations = Arrays.asList(allocation);
        List<String> result = allocationService.getGmiLookUpAc(allocations);

        assertEquals(1, result.size());
        assertTrue(result.contains("MATCH123"));
    }

    @Test
    public void testAddFtype_WhenCMEGroup() {
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getGmiExchCdC()).thenReturn("CME");

        String result = allocationService.addFtype(alloc, "first", "withFtype");
        assertNotNull(result);
    }

    @Test
    public void testAddFtpric_WhenPriceNotMatched() {
        TAllocationGenericId alloc = mock(TAllocationGenericId.class);
        when(alloc.getClientC()).thenReturn("MOORECAP");
        when(alloc.getIsGmiPriceMatch()).thenReturn("N");

        allocationService.currentJob = ImlAllocationJobs.jobs.SUM_FILL_BROKER_NO_PRICE;

        String result = allocationService.addFtpric(alloc, "withFtpric");
        assertNotNull(result);
    }
}
